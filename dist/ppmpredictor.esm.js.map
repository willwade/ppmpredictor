{"version":3,"file":"ppmpredictor.esm.js","sources":["../assert","../src/vocabulary.js","../src/ppm_language_model.js","../src/utils/fuzzy-matcher.js","../src/utils/word-tokenizer.js","../src/predictor.js","../src/index.browser.js","../src/index.browser.js?commonjs-entry"],"sourcesContent":["\n        export default function assert(condition, message) {\n          if (!condition) {\n            throw new Error(message || 'Assertion failed');\n          }\n        }\n      ","// Copyright 2025 The Google Research Authors.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Simple vocabulary abstraction.\r\n *\r\n * This is used to store symbols and map them to contiguous integers.\r\n */\r\n\r\n// Special symbol denoting the root node.\r\nconst rootSymbol = 0;\r\n\r\n// Symbol name of the root symbol, also used for out-of-vocabulary symbols.\r\nconst rootSymbolName = \"<R>\";\r\n\r\n// The special out-of-vocabulary (OOV) symbol.\r\nconst oovSymbol = \"<OOV>\";\r\n\r\n/**\r\n * Vocabulary of symbols, which is a set of symbols that map one-to-one to\r\n * unique integers.\r\n * @final\r\n */\r\nclass Vocabulary {\r\n  constructor() {\r\n    this.symbols_ = Array();\r\n    this.symbols_.push(rootSymbolName);\r\n    this.oovSymbol_ = -1;\r\n  }\r\n\r\n  /**\r\n   * Adds symbol to the vocabulary returning its unique ID.\r\n   * @param {string} symbol Symbol to be added.\r\n   * @return {number} Symbol ID.\r\n   * @final\r\n   */\r\n  addSymbol(symbol) {\r\n    let pos = this.symbols_.indexOf(symbol);\r\n    if (pos >= 0) {\r\n      return pos;\r\n    }\r\n    // The current symbol container length is used as a unique ID. Because\r\n    // the symbol IDs are used to index the array directly, the symbol ID is\r\n    // assigned before updating the array.\r\n    const symbol_id = this.symbols_.length;\r\n    this.symbols_.push(symbol);\r\n    return symbol_id;\r\n  }\r\n\r\n  /**\r\n   * Returns the vocabulary symbol ID if it exists, otherwise maps the supplied\r\n   * symbol to out-of-vocabulary (OOV) symbol. Note, this method is *only* used\r\n   * for testing.\r\n   * @param {string} symbol Symbol to be looked up.\r\n   * @return {number} Symbol ID.\r\n   * @final\r\n   */\r\n  getSymbolOrOOV(symbol) {\r\n    let pos = this.symbols_.indexOf(symbol);\r\n    if (pos >= 0) {\r\n      return pos;\r\n    }\r\n    this.oovSymbol_ = this.addSymbol(oovSymbol);\r\n    return this.oovSymbol_;\r\n  }\r\n\r\n  /**\r\n   * Returns cardinality of the vocabulary.\r\n   * @return {number} Size.\r\n   * @final\r\n   */\r\n  size() {\r\n    return this.symbols_.length;\r\n  }\r\n}\r\n\r\n/**\r\n * Exported APIs.\r\n */\r\nexports.rootSymbol = rootSymbol;\r\nexports.Vocabulary = Vocabulary;","// Copyright 2025 The Google Research Authors.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Prediction by Partial Matching (PPM) language model.\r\n *\r\n * The original PPM algorithm is described in [1]. This particular\r\n * implementation has been inspired by the PPM model used by Dasher, an\r\n * Augmentative and alternative communication (AAC) input method developed by\r\n * the Inference Group at University of Cambridge. The overview of the system\r\n * is provided in [2]. The details of this algorithm, which is different from\r\n * the standard PPM, are outlined in general terms in [3]. Please also see [4]\r\n * for an excellent overview of various PPM variants.\r\n *\r\n * References:\r\n * -----------\r\n *   [1] Cleary, John G. and Witten, Ian H. (1984): “Data Compression Using\r\n *       Adaptive Coding and Partial String Matching”, IEEE Transactions on\r\n *       Communications, vol. 32, no. 4, pp. 396–402.\r\n *   [2] Ward, David J. and Blackwell, Alan F. and MacKay, David J. C. (2000):\r\n *       “Dasher - A Data Entry Interface Using Continuous Gestures and\r\n *       Language Models”, UIST'00 Proceedings of the 13th annual ACM symposium\r\n *       on User interface software and technology, pp. 129–137, November, San\r\n *       Diego, USA.\r\n *   [3] Cowans, Phil (2005): “Language Modelling In Dasher -- A Tutorial”,\r\n *       June, Inference Lab, Cambridge University (presentation).\r\n *   [4] Jin Hu Huang and David Powers (2004): \"Adaptive Compression-based\r\n *       Approach for Chinese Pinyin Input.\" Proceedings of the Third SIGHAN\r\n *       Workshop on Chinese Language Processing, pp. 24--27, Barcelona, Spain,\r\n *       ACL.\r\n * Please also consult the references in README.md file in this directory.\r\n */\r\n\r\nconst assert = require(\"assert\");\r\n\r\nconst vocab = require(\"./vocabulary\");\r\n\r\n/**\r\n * Kneser-Ney \"-like\" smoothing parameters.\r\n *\r\n * These hardcoded values are copied from Dasher. Please see the documentation\r\n * for PPMLanguageModel.getProbs() below for more information.\r\n */\r\nconst knAlpha = 0.49;\r\nconst knBeta = 0.77;\r\n\r\n/* Epsilon for sanity checks. */\r\nconst epsilon = 1E-10;\r\n\r\n/**\r\n * Node in a search tree, which is implemented as a suffix trie that represents\r\n * every suffix of a sequence used during its construction. Please see\r\n *   [1] Moffat, Alistair (1990): \"Implementing the PPM data compression\r\n *       scheme\", IEEE Transactions on Communications, vol. 38, no. 11, pp.\r\n *       1917--1921.\r\n *   [2] Esko Ukknonen (1995): \"On-line construction of suffix trees\",\r\n *       Algorithmica, volume 14, pp. 249--260, Springer, 1995.\r\n *   [3] Kennington, C. (2011): \"Application of Suffix Trees as an\r\n *       Implementation Technique for Varied-Length N-gram Language Models\",\r\n *       MSc. Thesis, Saarland University.\r\n *\r\n * @final\r\n */\r\nclass Node {\r\n  constructor() {\r\n    // Leftmost child node for the current node.\r\n    this.child_ = null;\r\n    // Next node.\r\n    this.next_ = null;\r\n    // Node in the backoff structure, also known as \"vine\" structure (see [1]\r\n    // above) and \"suffix link\" (see [2] above). The backoff for the given node\r\n    // points at the node representing the shorter context. For example, if the\r\n    // current node in the trie represents string \"AA\" (corresponding to the\r\n    // branch \"[R] -> [A] -> [*A*]\" in the trie, where [R] stands for root),\r\n    // then its backoff points at the node \"A\" (represented by \"[R] ->\r\n    // [*A*]\"). In this case both nodes are in the same branch but they don't\r\n    // need to be. For example, for the node \"B\" in the trie path for the string\r\n    // \"AB\" (\"[R] -> [A] -> [*B*]\") the backoff points at the child node of a\r\n    // different path \"[R] -> [*B*]\".\r\n    this.backoff_ = null;\r\n    // Frequency count for this node. Number of times the suffix symbol stored\r\n    // in this node was observed.\r\n    this.count_ = 1;\r\n    // Symbol that this node stores.\r\n    this.symbol_ = vocab.rootSymbol;\r\n  }\r\n\r\n  /**\r\n   * Finds child of the current node with a specified symbol.\r\n   * @param {number} symbol Integer symbol.\r\n   * @return {?Node} Node with the symbol.\r\n   * @final\r\n   */\r\n  findChildWithSymbol(symbol) {\r\n    let current = this.child_;\r\n    while (current != null) {\r\n      if (current.symbol_ == symbol) {\r\n        return current;\r\n      }\r\n      current = current.next_;\r\n    }\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Total number of observations for all the children of this node. This\r\n   * counts all the events observed in this context.\r\n   *\r\n   * Note: This API is used at inference time. A possible alternative that will\r\n   * speed up the inference is to store the number of children in each node as\r\n   * originally proposed by Moffat for PPMB in\r\n   *   Moffat, Alistair (1990): \"Implementing the PPM data compression scheme\",\r\n   *   IEEE Transactions on Communications, vol. 38, no. 11, pp. 1917--1921.\r\n   * This however will increase the memory use of the algorithm which is already\r\n   * quite substantial.\r\n   *\r\n   * @param {!array} exclusionMask Boolean exclusion mask for all the symbols.\r\n   *                 Can be 'null', in which case no exclusion happens.\r\n   * @return {number} Total number of observations under this node.\r\n   * @final\r\n   */\r\n  totalChildrenCounts(exclusionMask) {\r\n    let childNode = this.child_;\r\n    let count = 0;\r\n    while (childNode != null) {\r\n      if (!exclusionMask || !exclusionMask[childNode.symbol_]) {\r\n        count += childNode.count_;\r\n      }\r\n      childNode = childNode.next_;\r\n    }\r\n    return count;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle encapsulating the search context.\r\n * @final\r\n */\r\nclass Context {\r\n  /**\r\n   * Constructor.\r\n   * @param {?Node} head Head node of the context.\r\n   * @param {number} order Length of the context.\r\n   */\r\n  constructor(head, order) {\r\n    // Current node.\r\n    this.head_ = head;\r\n    // The order corresponding to length of the context.\r\n    this.order_ = order;\r\n  }\r\n}\r\n\r\n/**\r\n * Prediction by Partial Matching (PPM) Language Model.\r\n * @final\r\n */\r\nclass PPMLanguageModel {\r\n  /**\r\n   * @param {?Vocabulary} vocab Symbol vocabulary object.\r\n   * @param {number} maxOrder Maximum length of the context.\r\n   */\r\n  constructor(vocab, maxOrder) {\r\n    this.vocab_ = vocab;\r\n    assert(this.vocab_.size() > 1,\r\n           \"Expecting at least two symbols in the vocabulary\");\r\n\r\n    this.maxOrder_ = maxOrder;\r\n    this.root_ = new Node();\r\n    this.rootContext_ = new Context();\r\n    this.rootContext_.head_ = this.root_;\r\n    this.rootContext_.order_ = 0;\r\n    this.numNodes_ = 1;\r\n\r\n    // Exclusion mechanism: Off by default, but can be enabled during the\r\n    // run-time once the constructed suffix tree contains reliable counts.\r\n    this.useExclusion_ = false;\r\n  }\r\n\r\n  /**\r\n   * Adds symbol to the supplied node.\r\n   * @param {?Node} node Tree node which to grow.\r\n   * @param {number} symbol Symbol.\r\n   * @return {?Node} Node with the symbol.\r\n   * @final @private\r\n   */\r\n  addSymbolToNode_(node, symbol) {\r\n    let symbolNode = node.findChildWithSymbol(symbol);\r\n    if (symbolNode != null) {\r\n      // Update the counts for the given node.  Only updates the counts for\r\n      // the highest order already existing node for the symbol ('single\r\n      // counting' or 'update exclusion').\r\n      symbolNode.count_++;\r\n    } else {\r\n      // Symbol does not exist under the given node. Create a new child node\r\n      // and update the backoff structure for lower contexts.\r\n      symbolNode = new Node();\r\n      symbolNode.symbol_ = symbol;\r\n      symbolNode.next_ = node.child_;\r\n      node.child_ = symbolNode;\r\n      this.numNodes_++;\r\n      if (node == this.root_) {\r\n        // Shortest possible context.\r\n        symbolNode.backoff_ = this.root_;\r\n      } else {\r\n        assert(node.backoff_ != null, \"Expected valid backoff node\");\r\n        symbolNode.backoff_ = this.addSymbolToNode_(node.backoff_, symbol);\r\n      }\r\n    }\r\n    return symbolNode;\r\n  }\r\n\r\n  /**\r\n   * Creates new context which is initially empty.\r\n   * @return {?Context} Context object.\r\n   * @final\r\n   */\r\n  createContext() {\r\n    return new Context(this.rootContext_.head_, this.rootContext_.order_);\r\n  }\r\n\r\n  /**\r\n   * Clones existing context.\r\n   * @param {?Context} context Existing context object.\r\n   * @return {?Context} Cloned context object.\r\n   * @final\r\n   */\r\n  cloneContext(context) {\r\n    return new Context(context.head_, context.order_);\r\n  }\r\n\r\n  /**\r\n   * Adds symbol to the supplied context. Does not update the model.\r\n   * @param {?Context} context Context object.\r\n   * @param {number} symbol Integer symbol.\r\n   * @final\r\n   */\r\n  addSymbolToContext(context, symbol) {\r\n    if (symbol <= vocab.rootSymbol) {  // Only add valid symbols.\r\n      return;\r\n    }\r\n    assert(symbol < this.vocab_.size(), \"Invalid symbol: \" + symbol);\r\n    while (context.head_ != null) {\r\n      if (context.order_ < this.maxOrder_) {\r\n        // Extend the current context.\r\n        const childNode = context.head_.findChildWithSymbol(symbol);\r\n        if (childNode != null) {\r\n          context.head_ = childNode;\r\n          context.order_++;\r\n          return;\r\n        }\r\n      }\r\n      // Try to extend the shorter context.\r\n      context.order_--;\r\n      context.head_ = context.head_.backoff_;\r\n    }\r\n    if (context.head_ == null) {\r\n      context.head_ = this.root_;\r\n      context.order_ = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds symbol to the supplied context and updates the model.\r\n   * @param {?Context} context Context object.\r\n   * @param {number} symbol Integer symbol.\r\n   * @final\r\n   */\r\n  addSymbolAndUpdate(context, symbol) {\r\n    if (symbol <= vocab.rootSymbol) {  // Only add valid symbols.\r\n      return;\r\n    }\r\n    assert(symbol < this.vocab_.size(), \"Invalid symbol: \" + symbol);\r\n    const symbolNode = this.addSymbolToNode_(context.head_, symbol);\r\n    assert(symbolNode == context.head_.findChildWithSymbol(symbol));\r\n    context.head_ = symbolNode;\r\n    context.order_++;\r\n    while (context.order_ > this.maxOrder_) {\r\n      context.head_ = context.head_.backoff_;\r\n      context.order_--;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns probabilities for all the symbols in the vocabulary given the\r\n   * context.\r\n   *\r\n   * Notation:\r\n   * ---------\r\n   *         $x_h$ : Context representing history, $x_{h-1}$ shorter context.\r\n   *   $n(w, x_h)$ : Count of symbol $w$ in context $x_h$.\r\n   *      $T(x_h)$ : Total count in context $x_h$.\r\n   *      $q(x_h)$ : Number of symbols with non-zero counts seen in context\r\n   *                 $x_h$, i.e. |{w' : c(x_h, w') > 0}|. Alternatively, this\r\n   *                 represents the number of distinct extensions of history\r\n   *                 $x_h$ in the training data.\r\n   *\r\n   * Standard Kneser-Ney method (aka Absolute Discounting):\r\n   * ------------------------------------------------------\r\n   * Subtracting \\beta (in [0, 1)) from all counts.\r\n   *   P_{kn}(w | x_h) = \\frac{\\max(n(w, x_h) - \\beta, 0)}{T(x_h)} +\r\n   *                     \\beta * \\frac{q(x_h)}{T(x_h)} * P_{kn}(w | x_{h-1}),\r\n   * where the second term in summation represents escaping to lower-order\r\n   * context.\r\n   *\r\n   * See: Ney, Reinhard and Kneser, Hermann (1995): “Improved backing-off for\r\n   * M-gram language modeling”, Proc. of Acoustics, Speech, and Signal\r\n   * Processing (ICASSP), May, pp. 181–184.\r\n   *\r\n   * Modified Kneser-Ney method (Dasher version [3]):\r\n   * ------------------------------------------------\r\n   * Introducing \\alpha parameter (in [0, 1)) and estimating as\r\n   *   P_{kn}(w | x_h) = \\frac{\\max(n(w, x_h) - \\beta, 0)}{T(x_h) + \\alpha} +\r\n   *                     \\frac{\\alpha + \\beta * q(x_h)}{T(x_h) + \\alpha} *\r\n   *                     P_{kn}(w | x_{h-1}) .\r\n   *\r\n   * Additional details on the above version are provided in Sections 3 and 4\r\n   * of:\r\n   *   Steinruecken, Christian and Ghahramani, Zoubin and MacKay, David (2016):\r\n   *   \"Improving PPM with dynamic parameter updates\", In Proc. Data\r\n   *   Compression Conference (DCC-2015), pp. 193--202, April, Snowbird, UT,\r\n   *   USA. IEEE.\r\n   *\r\n   * @param {?Context} context Context symbols.\r\n   * @return {?array} Array of floating point probabilities corresponding to all\r\n   *                  the symbols in the vocabulary plus the 0th element\r\n   *                  representing the root of the tree that should be ignored.\r\n   * @final\r\n   */\r\n  getProbs(context) {\r\n    // Initialize the initial estimates. Note, we don't use uniform\r\n    // distribution here.\r\n    const numSymbols = this.vocab_.size();\r\n    let probs = new Array(numSymbols);\r\n    for (let i = 0; i < numSymbols; ++i) {\r\n      probs[i] = 0.0;\r\n    }\r\n\r\n    // Initialize the exclusion mask.\r\n    let exclusionMask = null;\r\n    if (this.useExclusion_) {\r\n      exclusionMask = new Array(numSymbols);\r\n      for (let i = 0; i < numSymbols; ++i) {\r\n        exclusionMask[i] = false;\r\n      }\r\n    }\r\n\r\n    // Estimate the probabilities for all the symbols in the supplied context.\r\n    // This runs over all the symbols in the context and over all the suffixes\r\n    // (orders) of the context. If the exclusion mechanism is enabled, the\r\n    // estimate for a higher-order ngram is fully trusted and is excluded from\r\n    // further interpolation with lower-order estimates.\r\n    //\r\n    // Exclusion mechanism is disabled by default. Enable it with care: it has\r\n    // been shown to work well on large corpora, but may in theory degrade the\r\n    // performance on smaller sets (as we observed with default Dasher English\r\n    // training data).\r\n    let totalMass = 1.0;\r\n    let node = context.head_;\r\n    let gamma = totalMass;\r\n    while (node != null) {\r\n      const count = node.totalChildrenCounts(exclusionMask);\r\n      if (count > 0) {\r\n        let childNode = node.child_;\r\n        while (childNode != null) {\r\n          const symbol = childNode.symbol_;\r\n          if (!exclusionMask || !exclusionMask[symbol]) {\r\n            const p = gamma * (childNode.count_ - knBeta) / (count + knAlpha);\r\n            probs[symbol] += p;\r\n            totalMass -= p;\r\n            if (exclusionMask) {\r\n              exclusionMask[symbol] = true;\r\n            }\r\n          }\r\n          childNode = childNode.next_;\r\n        }\r\n      }\r\n\r\n      // Backoff to lower-order context. The $\\gamma$ factor represents the\r\n      // total probability mass after processing the current $n$-th order before\r\n      // backing off to $n-1$-th order. It roughly corresponds to the usual\r\n      // interpolation parameter, as used in the literature, e.g. in\r\n      //   Stanley F. Chen and Joshua Goodman (1999): \"An empirical study of\r\n      //   smoothing techniques for language modeling\", Computer Speech and\r\n      //   Language, vol. 13, pp. 359-–394.\r\n      //\r\n      // Note on computing $gamma$:\r\n      // --------------------------\r\n      // According to the PPM papers, and in particular the Section 4 of\r\n      //   Steinruecken, Christian and Ghahramani, Zoubin and MacKay,\r\n      //   David (2016): \"Improving PPM with dynamic parameter updates\", In\r\n      //   Proc. Data Compression Conference (DCC-2015), pp. 193--202, April,\r\n      //   Snowbird, UT, USA. IEEE,\r\n      // that describes blending (i.e. interpolation), the second multiplying\r\n      // factor in the interpolation $\\lambda$ for a given suffix node $x_h$ in\r\n      // the tree is given by\r\n      //   \\lambda(x_h) = \\frac{q(x_h) * \\beta + \\alpha}{T(x_h) + \\alpha} .\r\n      // It can be shown that\r\n      //   \\gamma(x_h) = 1.0 - \\sum_{w'}\r\n      //      \\frac{\\max(n(w', x_h) - \\beta, 0)}{T(x_h) + \\alpha} =\r\n      //      \\lambda(x_h)\r\n      // and, in the update below, the following is equivalent:\r\n      //   \\gamma = \\gamma * \\gamma(x_h) = totalMass .\r\n      //\r\n      // Since gamma *= (numChildren * knBeta + knAlpha) / (count + knAlpha) is\r\n      // expensive, we assign the equivalent totalMass value to gamma.\r\n      node = node.backoff_;\r\n      gamma = totalMass;\r\n    }\r\n    assert(totalMass >= 0.0,\r\n           \"Invalid remaining probability mass: \" + totalMass);\r\n\r\n    // Count the total number of symbols that should have their estimates\r\n    // blended with the uniform distribution representing the zero context.\r\n    // When exclusion mechanism is enabled (by enabling this.useExclusion_)\r\n    // this number will represent the number of symbols not seen during the\r\n    // training, otherwise, this number will be equal to total number of\r\n    // symbols because we always interpolate with the estimates for an empty\r\n    // context.\r\n    let numUnseenSymbols = 0;\r\n    for (let i = 1; i < numSymbols; ++i) {\r\n      if (!exclusionMask || !exclusionMask[i]) {\r\n        numUnseenSymbols++;\r\n      }\r\n    }\r\n\r\n    // Adjust the probability mass for all the symbols.\r\n    const remainingMass = totalMass;\r\n    for (let i = 1; i < numSymbols; ++i) {\r\n      // Following is estimated according to a uniform distribution\r\n      // corresponding to the context length of zero.\r\n      if (!exclusionMask || !exclusionMask[i]) {\r\n        const p = remainingMass / numUnseenSymbols;\r\n        probs[i] += p;\r\n        totalMass -= p;\r\n      }\r\n    }\r\n    let leftSymbols = numSymbols - 1;\r\n    let newProbMass = 0.0;\r\n    for (let i = 1; i < numSymbols; ++i) {\r\n      const p = totalMass / leftSymbols;\r\n      probs[i] += p;\r\n      totalMass -= p;\r\n      newProbMass += probs[i];\r\n      --leftSymbols;\r\n    }\r\n    assert(totalMass == 0.0, \"Expected remaining probability mass to be zero!\");\r\n    assert(Math.abs(1.0 - newProbMass) < epsilon);\r\n    return probs;\r\n  }\r\n\r\n  /**\r\n   * Prints the trie to console.\r\n   * @param {?Node} node Current trie node.\r\n   * @param {string} indent Indentation prefix.\r\n   * @final @private\r\n   */\r\n  printToConsole_(node, indent) {\r\n    console.log(indent + \"  \" + this.vocab_.symbols_[node.symbol_] +\r\n                \"(\" + node.symbol_ + \") [\" + node.count_ + \"]\");\r\n    indent += \"  \";\r\n    let child = node.child_;\r\n    while (child != null) {\r\n      this.printToConsole_(child, indent);\r\n      child = child.next_;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prints the trie to console.\r\n   * @final\r\n   */\r\n  printToConsole() {\r\n    this.printToConsole_(this.root_, \"\");\r\n  }\r\n}\r\n\r\n/**\r\n * Exported APIs.\r\n */\r\nexports.PPMLanguageModel = PPMLanguageModel;","// Copyright 2025 Will Wade\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Fuzzy matching utilities for error-tolerant prediction.\n * \n * Provides functions for calculating string similarity and filtering\n * predictions based on edit distance and other similarity metrics.\n */\n\n/**\n * Calculate Levenshtein distance between two strings.\n * @param {string} str1 First string.\n * @param {string} str2 Second string.\n * @return {number} Edit distance.\n */\nfunction levenshteinDistance(str1, str2) {\n  const len1 = str1.length;\n  const len2 = str2.length;\n  \n  // Create a 2D array for dynamic programming\n  const dp = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));\n  \n  // Initialize base cases\n  for (let i = 0; i <= len1; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= len2; j++) {\n    dp[0][j] = j;\n  }\n  \n  // Fill the dp table\n  for (let i = 1; i <= len1; i++) {\n    for (let j = 1; j <= len2; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = Math.min(\n          dp[i - 1][j] + 1,      // deletion\n          dp[i][j - 1] + 1,      // insertion\n          dp[i - 1][j - 1] + 1   // substitution\n        );\n      }\n    }\n  }\n  \n  return dp[len1][len2];\n}\n\n/**\n * Calculate similarity score between two strings (0-1, higher is more similar).\n * @param {string} str1 First string.\n * @param {string} str2 Second string.\n * @return {number} Similarity score between 0 and 1.\n */\nfunction similarityScore(str1, str2) {\n  const maxLen = Math.max(str1.length, str2.length);\n  if (maxLen === 0) return 1.0;\n  \n  const distance = levenshteinDistance(str1, str2);\n  return 1.0 - (distance / maxLen);\n}\n\n/**\n * Check if a string starts with a prefix (case-insensitive option).\n * @param {string} str The string to check.\n * @param {string} prefix The prefix to look for.\n * @param {boolean} caseSensitive Whether to do case-sensitive matching.\n * @return {boolean} True if str starts with prefix.\n */\nfunction startsWith(str, prefix, caseSensitive = true) {\n  if (!caseSensitive) {\n    str = str.toLowerCase();\n    prefix = prefix.toLowerCase();\n  }\n  return str.startsWith(prefix);\n}\n\n/**\n * Filter and rank strings by similarity to a target string.\n * @param {string} target Target string to match against.\n * @param {Array<string>} candidates Array of candidate strings.\n * @param {number} maxDistance Maximum edit distance to include.\n * @param {number} minSimilarity Minimum similarity score (0-1) to include.\n * @return {Array<{text: string, distance: number, similarity: number}>} \n *         Sorted array of matches with scores.\n */\nfunction fuzzyMatch(target, candidates, maxDistance = 2, minSimilarity = 0.5) {\n  const matches = [];\n  \n  for (const candidate of candidates) {\n    const distance = levenshteinDistance(target, candidate);\n    const similarity = similarityScore(target, candidate);\n    \n    if (distance <= maxDistance && similarity >= minSimilarity) {\n      matches.push({\n        text: candidate,\n        distance: distance,\n        similarity: similarity\n      });\n    }\n  }\n  \n  // Sort by similarity (descending) then by distance (ascending)\n  matches.sort((a, b) => {\n    if (Math.abs(a.similarity - b.similarity) > 0.001) {\n      return b.similarity - a.similarity;\n    }\n    return a.distance - b.distance;\n  });\n  \n  return matches;\n}\n\n/**\n * Get keyboard adjacency map for QWERTY layout.\n * Used for keyboard-proximity-based error tolerance.\n * @return {Object} Map of characters to their adjacent keys.\n */\nfunction getQwertyAdjacency() {\n  return {\n    'q': ['w', 'a', 's'],\n    'w': ['q', 'e', 'a', 's', 'd'],\n    'e': ['w', 'r', 's', 'd', 'f'],\n    'r': ['e', 't', 'd', 'f', 'g'],\n    't': ['r', 'y', 'f', 'g', 'h'],\n    'y': ['t', 'u', 'g', 'h', 'j'],\n    'u': ['y', 'i', 'h', 'j', 'k'],\n    'i': ['u', 'o', 'j', 'k', 'l'],\n    'o': ['i', 'p', 'k', 'l'],\n    'p': ['o', 'l'],\n    'a': ['q', 'w', 's', 'z', 'x'],\n    's': ['q', 'w', 'e', 'a', 'd', 'z', 'x', 'c'],\n    'd': ['w', 'e', 'r', 's', 'f', 'x', 'c', 'v'],\n    'f': ['e', 'r', 't', 'd', 'g', 'c', 'v', 'b'],\n    'g': ['r', 't', 'y', 'f', 'h', 'v', 'b', 'n'],\n    'h': ['t', 'y', 'u', 'g', 'j', 'b', 'n', 'm'],\n    'j': ['y', 'u', 'i', 'h', 'k', 'n', 'm'],\n    'k': ['u', 'i', 'o', 'j', 'l', 'm'],\n    'l': ['i', 'o', 'p', 'k'],\n    'z': ['a', 's', 'x'],\n    'x': ['a', 's', 'd', 'z', 'c'],\n    'c': ['s', 'd', 'f', 'x', 'v'],\n    'v': ['d', 'f', 'g', 'c', 'b'],\n    'b': ['f', 'g', 'h', 'v', 'n'],\n    'n': ['g', 'h', 'j', 'b', 'm'],\n    'm': ['h', 'j', 'k', 'n']\n  };\n}\n\n/**\n * Check if two characters are adjacent on a QWERTY keyboard.\n * @param {string} char1 First character.\n * @param {string} char2 Second character.\n * @return {boolean} True if characters are adjacent.\n */\nfunction areKeysAdjacent(char1, char2) {\n  const adjacency = getQwertyAdjacency();\n  const c1 = char1.toLowerCase();\n  const c2 = char2.toLowerCase();\n  \n  return adjacency[c1] && adjacency[c1].includes(c2);\n}\n\n/**\n * Calculate keyboard-aware edit distance.\n * Substitutions between adjacent keys cost less than non-adjacent keys.\n * @param {string} str1 First string.\n * @param {string} str2 Second string.\n * @return {number} Keyboard-aware edit distance.\n */\nfunction keyboardAwareDistance(str1, str2) {\n  const len1 = str1.length;\n  const len2 = str2.length;\n  \n  const dp = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));\n  \n  for (let i = 0; i <= len1; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= len2; j++) {\n    dp[0][j] = j;\n  }\n  \n  for (let i = 1; i <= len1; i++) {\n    for (let j = 1; j <= len2; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        // Check if keys are adjacent for substitution cost\n        const substCost = areKeysAdjacent(str1[i - 1], str2[j - 1]) ? 0.5 : 1.0;\n        \n        dp[i][j] = Math.min(\n          dp[i - 1][j] + 1,              // deletion\n          dp[i][j - 1] + 1,              // insertion\n          dp[i - 1][j - 1] + substCost   // substitution\n        );\n      }\n    }\n  }\n  \n  return dp[len1][len2];\n}\n\n/**\n * Exported APIs.\n */\nexports.levenshteinDistance = levenshteinDistance;\nexports.similarityScore = similarityScore;\nexports.startsWith = startsWith;\nexports.fuzzyMatch = fuzzyMatch;\nexports.getQwertyAdjacency = getQwertyAdjacency;\nexports.areKeysAdjacent = areKeysAdjacent;\nexports.keyboardAwareDistance = keyboardAwareDistance;\n\n","// Copyright 2025 Will Wade\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Word tokenization utilities.\n * \n * Provides functions for splitting text into words and handling\n * word boundaries for prediction.\n */\n\n/**\n * Tokenize text into words.\n * @param {string} text Text to tokenize.\n * @return {Array<string>} Array of words.\n */\nfunction tokenize(text) {\n  if (!text || typeof text !== 'string') {\n    return [];\n  }\n  \n  // Split on whitespace and punctuation, but keep the tokens\n  return text.trim().split(/\\s+/).filter(word => word.length > 0);\n}\n\n/**\n * Get the last partial word from text (for word completion).\n * @param {string} text Input text.\n * @return {string} The last partial word.\n */\nfunction getLastPartialWord(text) {\n  if (!text || typeof text !== 'string') {\n    return '';\n  }\n  \n  const trimmed = text.trimEnd();\n  const words = trimmed.split(/\\s+/);\n  \n  // If text ends with whitespace, there's no partial word\n  if (text !== trimmed) {\n    return '';\n  }\n  \n  return words[words.length - 1] || '';\n}\n\n/**\n * Get the context (all words except the last partial word).\n * @param {string} text Input text.\n * @return {string} Context text.\n */\nfunction getContext(text) {\n  if (!text || typeof text !== 'string') {\n    return '';\n  }\n  \n  const trimmed = text.trimEnd();\n  const words = trimmed.split(/\\s+/);\n  \n  // If text ends with whitespace, all words are context\n  if (text !== trimmed) {\n    return trimmed;\n  }\n  \n  // Otherwise, exclude the last word\n  if (words.length <= 1) {\n    return '';\n  }\n  \n  return words.slice(0, -1).join(' ');\n}\n\n/**\n * Check if text ends with a word boundary (whitespace).\n * @param {string} text Input text.\n * @return {boolean} True if text ends with whitespace.\n */\nfunction endsWithWordBoundary(text) {\n  if (!text || typeof text !== 'string') {\n    return true;\n  }\n  \n  return text !== text.trimEnd();\n}\n\n/**\n * Normalize text for prediction (lowercase, trim).\n * @param {string} text Input text.\n * @param {boolean} lowercase Whether to convert to lowercase.\n * @return {string} Normalized text.\n */\nfunction normalize(text, lowercase = true) {\n  if (!text || typeof text !== 'string') {\n    return '';\n  }\n  \n  let normalized = text.trim();\n  if (lowercase) {\n    normalized = normalized.toLowerCase();\n  }\n  \n  return normalized;\n}\n\n/**\n * Split text into characters, handling special cases.\n * @param {string} text Input text.\n * @return {Array<string>} Array of characters.\n */\nfunction toCharArray(text) {\n  if (!text || typeof text !== 'string') {\n    return [];\n  }\n  \n  return Array.from(text);\n}\n\n/**\n * Join an array of characters into a string.\n * @param {Array<string>} chars Array of characters.\n * @return {string} Joined string.\n */\nfunction fromCharArray(chars) {\n  if (!Array.isArray(chars)) {\n    return '';\n  }\n  \n  return chars.join('');\n}\n\n/**\n * Get n-grams from text.\n * @param {string} text Input text.\n * @param {number} n Size of n-grams.\n * @return {Array<string>} Array of n-grams.\n */\nfunction getNgrams(text, n) {\n  if (!text || typeof text !== 'string' || n < 1) {\n    return [];\n  }\n  \n  const chars = toCharArray(text);\n  const ngrams = [];\n  \n  for (let i = 0; i <= chars.length - n; i++) {\n    ngrams.push(chars.slice(i, i + n).join(''));\n  }\n  \n  return ngrams;\n}\n\n/**\n * Remove punctuation from text.\n * @param {string} text Input text.\n * @return {string} Text without punctuation.\n */\nfunction removePunctuation(text) {\n  if (!text || typeof text !== 'string') {\n    return '';\n  }\n  \n  return text.replace(/[^\\w\\s]/g, '');\n}\n\n/**\n * Check if a character is alphanumeric.\n * @param {string} char Character to check.\n * @return {boolean} True if alphanumeric.\n */\nfunction isAlphanumeric(char) {\n  if (!char || typeof char !== 'string' || char.length !== 1) {\n    return false;\n  }\n  \n  return /^[a-zA-Z0-9]$/.test(char);\n}\n\n/**\n * Check if a character is whitespace.\n * @param {string} char Character to check.\n * @return {boolean} True if whitespace.\n */\nfunction isWhitespace(char) {\n  if (!char || typeof char !== 'string' || char.length !== 1) {\n    return false;\n  }\n  \n  return /^\\s$/.test(char);\n}\n\n/**\n * Exported APIs.\n */\nexports.tokenize = tokenize;\nexports.getLastPartialWord = getLastPartialWord;\nexports.getContext = getContext;\nexports.endsWithWordBoundary = endsWithWordBoundary;\nexports.normalize = normalize;\nexports.toCharArray = toCharArray;\nexports.fromCharArray = fromCharArray;\nexports.getNgrams = getNgrams;\nexports.removePunctuation = removePunctuation;\nexports.isAlphanumeric = isAlphanumeric;\nexports.isWhitespace = isWhitespace;\n\n","// Copyright 2025 Will Wade\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview High-level prediction API wrapping PPM language model.\n * \n * Provides word and letter prediction with configurable error tolerance.\n */\n\nconst ppm = require('./ppm_language_model');\nconst vocab = require('./vocabulary');\nconst fuzzy = require('./utils/fuzzy-matcher');\nconst tokenizer = require('./utils/word-tokenizer');\n\n/**\n * Configuration options for the predictor.\n * @typedef {Object} PredictorConfig\n * @property {number} maxOrder - Maximum context length for PPM (default: 5)\n * @property {boolean} errorTolerant - Enable error-tolerant mode (default: false)\n * @property {number} maxEditDistance - Maximum edit distance for fuzzy matching (default: 2)\n * @property {number} minSimilarity - Minimum similarity score 0-1 (default: 0.5)\n * @property {boolean} keyboardAware - Use keyboard-aware distance (default: false)\n * @property {boolean} caseSensitive - Case-sensitive matching (default: false)\n * @property {number} maxPredictions - Maximum number of predictions to return (default: 10)\n * @property {boolean} adaptive - Update model as text is entered (default: false)\n * @property {Array<string>} lexicon - Optional word list for word prediction\n */\n\n/**\n * Prediction result.\n * @typedef {Object} Prediction\n * @property {string} text - Predicted text\n * @property {number} probability - Probability score (0-1)\n * @property {number} [distance] - Edit distance (only in error-tolerant mode)\n * @property {number} [similarity] - Similarity score (only in error-tolerant mode)\n */\n\n/**\n * Predictor class providing word and letter prediction.\n */\nclass Predictor {\n  /**\n   * Constructor.\n   * @param {PredictorConfig} config Configuration options.\n   */\n  constructor(config = {}) {\n    // Set default configuration\n    this.config = {\n      maxOrder: config.maxOrder || 5,\n      errorTolerant: config.errorTolerant !== undefined ? config.errorTolerant : false,\n      maxEditDistance: config.maxEditDistance || 2,\n      minSimilarity: config.minSimilarity || 0.5,\n      keyboardAware: config.keyboardAware !== undefined ? config.keyboardAware : false,\n      caseSensitive: config.caseSensitive !== undefined ? config.caseSensitive : false,\n      maxPredictions: config.maxPredictions || 10,\n      adaptive: config.adaptive !== undefined ? config.adaptive : false,\n      lexicon: config.lexicon || []\n    };\n\n    // Create vocabulary\n    this.vocab = new vocab.Vocabulary();\n    \n    // Add all printable ASCII characters to vocabulary\n    for (let i = 32; i <= 126; i++) {\n      this.vocab.addSymbol(String.fromCharCode(i));\n    }\n    \n    // Add common special characters\n    this.vocab.addSymbol('\\n');\n    this.vocab.addSymbol('\\t');\n    \n    // Create PPM language model\n    this.model = new ppm.PPMLanguageModel(this.vocab, this.config.maxOrder);\n    \n    // Create context\n    this.context = this.model.createContext();\n    \n    // Build lexicon index if provided\n    this.lexiconIndex = new Set(this.config.lexicon.map(word => \n      this.config.caseSensitive ? word : word.toLowerCase()\n    ));\n  }\n\n  /**\n   * Train the model on text.\n   * @param {string} text Training text.\n   */\n  train(text) {\n    if (!text || typeof text !== 'string') {\n      return;\n    }\n\n    const chars = tokenizer.toCharArray(text);\n    const context = this.model.createContext();\n    \n    for (const char of chars) {\n      const symbolId = this.vocab.addSymbol(char);\n      this.model.addSymbolAndUpdate(context, symbolId);\n    }\n  }\n\n  /**\n   * Reset the prediction context.\n   */\n  resetContext() {\n    this.context = this.model.createContext();\n  }\n\n  /**\n   * Add text to the current context.\n   * @param {string} text Text to add to context.\n   * @param {boolean} update Whether to update the model (adaptive mode).\n   */\n  addToContext(text, update = null) {\n    if (!text || typeof text !== 'string') {\n      return;\n    }\n\n    const shouldUpdate = update !== null ? update : this.config.adaptive;\n    const chars = tokenizer.toCharArray(text);\n    \n    for (const char of chars) {\n      let symbolId = this.vocab.symbols_.indexOf(char);\n      if (symbolId < 0) {\n        symbolId = this.vocab.addSymbol(char);\n      }\n      \n      if (shouldUpdate) {\n        this.model.addSymbolAndUpdate(this.context, symbolId);\n      } else {\n        this.model.addSymbolToContext(this.context, symbolId);\n      }\n    }\n  }\n\n  /**\n   * Get character/letter predictions.\n   * @param {string} context Optional context string (uses current context if not provided).\n   * @return {Array<Prediction>} Array of character predictions.\n   */\n  predictNextCharacter(context = null) {\n    let workingContext = this.context;\n    \n    if (context !== null) {\n      workingContext = this.model.createContext();\n      const chars = tokenizer.toCharArray(context);\n      for (const char of chars) {\n        let symbolId = this.vocab.symbols_.indexOf(char);\n        if (symbolId < 0) {\n          symbolId = this.vocab.addSymbol(char);\n        }\n        this.model.addSymbolToContext(workingContext, symbolId);\n      }\n    }\n\n    // Get probabilities from PPM model\n    const probs = this.model.getProbs(workingContext);\n    \n    // Convert to predictions array\n    const predictions = [];\n    for (let i = 1; i < probs.length; i++) {\n      if (probs[i] > 0) {\n        predictions.push({\n          text: this.vocab.symbols_[i],\n          probability: probs[i]\n        });\n      }\n    }\n    \n    // Sort by probability (descending)\n    predictions.sort((a, b) => b.probability - a.probability);\n    \n    // Return top N predictions\n    return predictions.slice(0, this.config.maxPredictions);\n  }\n\n  /**\n   * Get word completion predictions.\n   * @param {string} partialWord Partial word to complete.\n   * @param {string} precedingContext Optional preceding context.\n   * @return {Array<Prediction>} Array of word predictions.\n   */\n  predictWordCompletion(partialWord, precedingContext = '') {\n    if (!partialWord || typeof partialWord !== 'string') {\n      return [];\n    }\n\n    const normalized = this.config.caseSensitive ? partialWord : partialWord.toLowerCase();\n    \n    // If we have a lexicon, use it for word completion\n    if (this.lexiconIndex.size > 0) {\n      return this._predictFromLexicon(normalized, precedingContext);\n    }\n    \n    // Otherwise, use character-level prediction to build word completions\n    return this._predictCharacterBased(partialWord, precedingContext);\n  }\n\n  /**\n   * Predict word completions from lexicon.\n   * @param {string} partialWord Partial word (normalized).\n   * @param {string} precedingContext Preceding context.\n   * @return {Array<Prediction>} Array of word predictions.\n   * @private\n   */\n  _predictFromLexicon(partialWord, precedingContext) {\n    const candidates = [];\n    \n    // Find all words in lexicon that start with the partial word\n    for (const word of this.lexiconIndex) {\n      if (fuzzy.startsWith(word, partialWord, this.config.caseSensitive)) {\n        candidates.push(word);\n      }\n    }\n    \n    // In error-tolerant mode, also include fuzzy matches\n    if (this.config.errorTolerant && partialWord.length >= 2) {\n      const fuzzyMatches = fuzzy.fuzzyMatch(\n        partialWord,\n        Array.from(this.lexiconIndex),\n        this.config.maxEditDistance,\n        this.config.minSimilarity\n      );\n      \n      for (const match of fuzzyMatches) {\n        if (!candidates.includes(match.text)) {\n          candidates.push(match.text);\n        }\n      }\n    }\n    \n    // Score candidates using PPM model\n    return this._scoreCandidates(candidates, precedingContext);\n  }\n\n  /**\n   * Predict word completions using character-level model.\n   * @param {string} partialWord Partial word.\n   * @param {string} precedingContext Preceding context.\n   * @return {Array<Prediction>} Array of word predictions.\n   * @private\n   */\n  _predictCharacterBased(partialWord, precedingContext) {\n    const predictions = [];\n    const maxLength = 20; // Maximum word length to predict\n    \n    // Create a context with the preceding text and partial word\n    const fullContext = precedingContext + partialWord;\n    const workingContext = this.model.createContext();\n    \n    const chars = tokenizer.toCharArray(fullContext);\n    for (const char of chars) {\n      let symbolId = this.vocab.symbols_.indexOf(char);\n      if (symbolId >= 0) {\n        this.model.addSymbolToContext(workingContext, symbolId);\n      }\n    }\n    \n    // Generate completions by predicting next characters\n    const completions = this._generateCompletions(\n      workingContext,\n      partialWord,\n      maxLength - partialWord.length,\n      5 // Generate top 5 completions\n    );\n    \n    for (const completion of completions) {\n      predictions.push({\n        text: completion.text,\n        probability: completion.probability\n      });\n    }\n    \n    return predictions;\n  }\n\n  /**\n   * Generate word completions by predicting next characters.\n   * @param {Object} context PPM context.\n   * @param {string} prefix Current prefix.\n   * @param {number} maxChars Maximum characters to add.\n   * @param {number} numCompletions Number of completions to generate.\n   * @return {Array<Prediction>} Generated completions.\n   * @private\n   */\n  _generateCompletions(context, prefix, maxChars, numCompletions) {\n    const completions = [];\n    const spaceId = this.vocab.symbols_.indexOf(' ');\n    \n    // Simple beam search\n    let beams = [{ context: this.model.cloneContext(context), text: prefix, prob: 1.0 }];\n    \n    for (let i = 0; i < maxChars; i++) {\n      const newBeams = [];\n      \n      for (const beam of beams) {\n        const probs = this.model.getProbs(beam.context);\n        const topChars = [];\n        \n        // Get top characters\n        for (let j = 1; j < probs.length; j++) {\n          if (probs[j] > 0) {\n            topChars.push({ id: j, prob: probs[j] });\n          }\n        }\n        \n        topChars.sort((a, b) => b.prob - a.prob);\n        \n        // Expand beam with top characters\n        for (let k = 0; k < Math.min(3, topChars.length); k++) {\n          const charId = topChars[k].id;\n          const char = this.vocab.symbols_[charId];\n          \n          // Stop at space or newline\n          if (charId === spaceId || char === '\\n') {\n            if (beam.text.length > prefix.length) {\n              completions.push({ text: beam.text, probability: beam.prob });\n            }\n            continue;\n          }\n          \n          const newContext = this.model.cloneContext(beam.context);\n          this.model.addSymbolToContext(newContext, charId);\n          \n          newBeams.push({\n            context: newContext,\n            text: beam.text + char,\n            prob: beam.prob * topChars[k].prob\n          });\n        }\n      }\n      \n      if (newBeams.length === 0) break;\n      \n      // Keep top beams\n      newBeams.sort((a, b) => b.prob - a.prob);\n      beams = newBeams.slice(0, numCompletions);\n    }\n    \n    // Add remaining beams as completions\n    for (const beam of beams) {\n      if (beam.text.length > prefix.length) {\n        completions.push({ text: beam.text, probability: beam.prob });\n      }\n    }\n    \n    completions.sort((a, b) => b.probability - a.probability);\n    return completions.slice(0, numCompletions);\n  }\n\n  /**\n   * Score candidate words using the PPM model.\n   * @param {Array<string>} candidates Candidate words.\n   * @param {string} precedingContext Preceding context.\n   * @return {Array<Prediction>} Scored predictions.\n   * @private\n   */\n  _scoreCandidates(candidates, precedingContext) {\n    const predictions = [];\n    \n    for (const candidate of candidates) {\n      const score = this._scoreWord(candidate, precedingContext);\n      predictions.push({\n        text: candidate,\n        probability: score\n      });\n    }\n    \n    predictions.sort((a, b) => b.probability - a.probability);\n    return predictions.slice(0, this.config.maxPredictions);\n  }\n\n  /**\n   * Score a word using the PPM model.\n   * @param {string} word Word to score.\n   * @param {string} precedingContext Preceding context.\n   * @return {number} Score (probability).\n   * @private\n   */\n  _scoreWord(word, precedingContext) {\n    const fullText = precedingContext + word;\n    const workingContext = this.model.createContext();\n    \n    let logProb = 0;\n    const chars = tokenizer.toCharArray(fullText);\n    \n    for (const char of chars) {\n      const symbolId = this.vocab.symbols_.indexOf(char);\n      if (symbolId >= 0) {\n        const probs = this.model.getProbs(workingContext);\n        const prob = probs[symbolId] || 1e-10;\n        logProb += Math.log(prob);\n        this.model.addSymbolToContext(workingContext, symbolId);\n      }\n    }\n    \n    // Convert log probability to probability (normalized)\n    return Math.exp(logProb / chars.length);\n  }\n\n  /**\n   * Get configuration.\n   * @return {PredictorConfig} Current configuration.\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration.\n   * @param {Partial<PredictorConfig>} newConfig Configuration updates.\n   */\n  updateConfig(newConfig) {\n    this.config = { ...this.config, ...newConfig };\n    \n    // Rebuild lexicon index if lexicon changed\n    if (newConfig.lexicon) {\n      this.lexiconIndex = new Set(this.config.lexicon.map(word => \n        this.config.caseSensitive ? word : word.toLowerCase()\n      ));\n    }\n  }\n}\n\n/**\n * Exported APIs.\n */\nexports.Predictor = Predictor;\n\n","// Copyright 2025 Will Wade\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Browser-compatible entry point for noisy-channel-predictor.\n * \n * This version excludes Node.js-specific dependencies (like fs) and provides\n * a browser-friendly API.\n */\n\nconst predictorModule = require('./predictor');\nconst ppmModule = require('./ppm_language_model');\nconst vocabModule = require('./vocabulary');\nconst fuzzyMatcher = require('./utils/fuzzy-matcher');\nconst wordTokenizer = require('./utils/word-tokenizer');\n\n// Extract the actual classes from the modules\nconst Predictor = predictorModule.Predictor || predictorModule;\nconst PPMLanguageModel = ppmModule.PPMLanguageModel || ppmModule;\nconst Vocabulary = vocabModule.Vocabulary || vocabModule;\n\n/**\n * Create a new predictor instance.\n * \n * @param {Object} config - Configuration options\n * @returns {Predictor} Predictor instance\n */\nfunction createPredictor(config = {}) {\n  return new Predictor(config);\n}\n\n/**\n * Create a predictor with strict mode (exact matching only).\n * \n * @param {Object} config - Configuration options\n * @returns {Predictor} Predictor instance\n */\nfunction createStrictPredictor(config = {}) {\n  return new Predictor({\n    ...config,\n    errorTolerant: false\n  });\n}\n\n/**\n * Create a predictor with error-tolerant mode enabled.\n * \n * @param {Object} config - Configuration options\n * @returns {Predictor} Predictor instance\n */\nfunction createErrorTolerantPredictor(config = {}) {\n  return new Predictor({\n    ...config,\n    errorTolerant: true\n  });\n}\n\n// Export for different module systems\nconst PPMPredictor = {\n  // Factory functions\n  createPredictor,\n  createStrictPredictor,\n  createErrorTolerantPredictor,\n\n  // Classes\n  Predictor,\n  PPMLanguageModel,\n  Vocabulary,\n\n  // Utilities\n  fuzzyMatcher,\n  wordTokenizer,\n\n  // Convenience exports\n  levenshteinDistance: fuzzyMatcher.levenshteinDistance,\n  similarityScore: fuzzyMatcher.similarityScore,\n  fuzzyMatch: fuzzyMatcher.fuzzyMatch\n};\n\n// UMD export\nif (typeof module !== 'undefined' && module.exports) {\n  // CommonJS\n  module.exports = PPMPredictor;\n  module.exports.createPredictor = createPredictor;\n  module.exports.createStrictPredictor = createStrictPredictor;\n  module.exports.createErrorTolerantPredictor = createErrorTolerantPredictor;\n  module.exports.Predictor = Predictor;\n  module.exports.PPMLanguageModel = PPMLanguageModel;\n  module.exports.Vocabulary = Vocabulary;\n  module.exports.fuzzyMatcher = fuzzyMatcher;\n  module.exports.wordTokenizer = wordTokenizer;\n  module.exports.levenshteinDistance = fuzzyMatcher.levenshteinDistance;\n  module.exports.similarityScore = fuzzyMatcher.similarityScore;\n  module.exports.fuzzyMatch = fuzzyMatcher.fuzzyMatch;\n}\n\nif (typeof window !== 'undefined') {\n  // Browser global\n  window.PPMPredictor = PPMPredictor;\n}\n\n// Default export\nmodule.exports = PPMPredictor;\n\n","import { getDefaultExportFromCjs } from \"\u0000commonjsHelpers.js\";\nimport { __require as requireIndex_browser } from \"C:\\\\Users\\\\admin.will\\\\Documents\\\\GitHub\\\\noisy-channel-correction\\\\js\\\\src\\\\index.browser.js\";\nvar index_browserExports = requireIndex_browser();\nexport { index_browserExports as __moduleExports };\nexport default /*@__PURE__*/getDefaultExportFromCjs(index_browserExports);"],"names":["require$$1","require$$0","require$$2","require$$3","require$$4"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACuB,SAAS,MAAM,CAAC,SAAS,EAAE,OAAO,EAAE;AAC3D,UAAU,IAAI,CAAC,SAAS,EAAE;AAC1B,YAAY,MAAM,IAAI,KAAK,CAAC,OAAO,IAAI,kBAAkB,CAAC;AAC1D,UAAU;AACV,QAAQ;;;;;;;;;;;;;;;;ACLR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CACA,MAAM,UAAU,GAAG,CAAC,CAAC;AACrB;AACA;CACA,MAAM,cAAc,GAAG,KAAK,CAAC;AAC7B;AACA;CACA,MAAM,SAAS,GAAG,OAAO,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,CAAA,MAAM,UAAU,CAAC;AACjB,GAAE,WAAW,GAAG;AAChB,KAAI,IAAI,CAAC,QAAQ,GAAG,KAAK,EAAE,CAAC;KACxB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;AACvC,KAAI,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;GACzB,CAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;GACE,SAAS,CAAC,MAAM,EAAE;KAChB,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;AAC5C,KAAI,IAAI,GAAG,IAAI,CAAC,EAAE;OACZ,OAAO,GAAG,CAAC;KACjB,CAAK;AACL;AACA;AACA;KACI,MAAM,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;KACvC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KAC3B,OAAO,SAAS,CAAC;GACrB,CAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;GACE,cAAc,CAAC,MAAM,EAAE;KACrB,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;AAC5C,KAAI,IAAI,GAAG,IAAI,CAAC,EAAE;OACZ,OAAO,GAAG,CAAC;KACjB,CAAK;KACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;AAChD,KAAI,OAAO,IAAI,CAAC,UAAU,CAAC;GAC3B,CAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAE,IAAI,GAAG;AACT,KAAI,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;GAChC,CAAG;EACF;AACD;AACA;AACA;AACA;AACA,CAAA,UAAA,CAAA,UAAkB,GAAG,UAAU,CAAC;AAChC,CAAA,UAAA,CAAA,UAAkB,GAAG,UAAU;;;;;;;;;AC3F/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CACA,MAAM,MAAM,GAAG,UAAiB,CAAC;AACjC;CACA,MAAM,KAAK,GAAGA,iBAAA,EAAuB,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;CACA,MAAM,OAAO,GAAG,IAAI,CAAC;CACrB,MAAM,MAAM,GAAG,IAAI,CAAC;AACpB;AACA;CACA,MAAM,OAAO,GAAG,KAAK,CAAC;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA,MAAM,IAAI,CAAC;AACX,GAAE,WAAW,GAAG;AAChB;AACA,KAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;AACvB;AACA,KAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AACzB;AACA;AACA,KAAI,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;AACpB;AACA,KAAI,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,UAAU,CAAC;GACpC,CAAG;AACH;AACA;AACA;AACA;AACA;AACA;AA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AAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;KAC9B,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAC7B,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;AACnB,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AACjD,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AACjD,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AACjD,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AACjD,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AACjD,KAAI,GAAG,EAAE,CAAC,GAAG,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"}