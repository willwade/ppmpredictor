{"version":3,"file":"ppmpredictor.js","sources":["../assert","../src/vocabulary.js","../src/ppm_language_model.js","../src/utils/fuzzy-matcher.js","../src/utils/word-tokenizer.js","../src/predictor.js","../src/index.browser.js","../src/index.browser.js?commonjs-entry"],"sourcesContent":["\n        export default function assert(condition, message) {\n          if (!condition) {\n            throw new Error(message || 'Assertion failed');\n          }\n        }\n      ","// Copyright 2025 The Google Research Authors.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Simple vocabulary abstraction.\r\n *\r\n * This is used to store symbols and map them to contiguous integers.\r\n */\r\n\r\n// Special symbol denoting the root node.\r\nconst rootSymbol = 0;\r\n\r\n// Symbol name of the root symbol, also used for out-of-vocabulary symbols.\r\nconst rootSymbolName = \"<R>\";\r\n\r\n// The special out-of-vocabulary (OOV) symbol.\r\nconst oovSymbol = \"<OOV>\";\r\n\r\n/**\r\n * Vocabulary of symbols, which is a set of symbols that map one-to-one to\r\n * unique integers.\r\n * @final\r\n */\r\nclass Vocabulary {\r\n  constructor() {\r\n    this.symbols_ = Array();\r\n    this.symbols_.push(rootSymbolName);\r\n    this.oovSymbol_ = -1;\r\n  }\r\n\r\n  /**\r\n   * Adds symbol to the vocabulary returning its unique ID.\r\n   * @param {string} symbol Symbol to be added.\r\n   * @return {number} Symbol ID.\r\n   * @final\r\n   */\r\n  addSymbol(symbol) {\r\n    let pos = this.symbols_.indexOf(symbol);\r\n    if (pos >= 0) {\r\n      return pos;\r\n    }\r\n    // The current symbol container length is used as a unique ID. Because\r\n    // the symbol IDs are used to index the array directly, the symbol ID is\r\n    // assigned before updating the array.\r\n    const symbol_id = this.symbols_.length;\r\n    this.symbols_.push(symbol);\r\n    return symbol_id;\r\n  }\r\n\r\n  /**\r\n   * Returns the vocabulary symbol ID if it exists, otherwise maps the supplied\r\n   * symbol to out-of-vocabulary (OOV) symbol. Note, this method is *only* used\r\n   * for testing.\r\n   * @param {string} symbol Symbol to be looked up.\r\n   * @return {number} Symbol ID.\r\n   * @final\r\n   */\r\n  getSymbolOrOOV(symbol) {\r\n    let pos = this.symbols_.indexOf(symbol);\r\n    if (pos >= 0) {\r\n      return pos;\r\n    }\r\n    this.oovSymbol_ = this.addSymbol(oovSymbol);\r\n    return this.oovSymbol_;\r\n  }\r\n\r\n  /**\r\n   * Returns cardinality of the vocabulary.\r\n   * @return {number} Size.\r\n   * @final\r\n   */\r\n  size() {\r\n    return this.symbols_.length;\r\n  }\r\n}\r\n\r\n/**\r\n * Exported APIs.\r\n */\r\nexports.rootSymbol = rootSymbol;\r\nexports.Vocabulary = Vocabulary;","// Copyright 2025 The Google Research Authors.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Prediction by Partial Matching (PPM) language model.\r\n *\r\n * The original PPM algorithm is described in [1]. This particular\r\n * implementation has been inspired by the PPM model used by Dasher, an\r\n * Augmentative and alternative communication (AAC) input method developed by\r\n * the Inference Group at University of Cambridge. The overview of the system\r\n * is provided in [2]. The details of this algorithm, which is different from\r\n * the standard PPM, are outlined in general terms in [3]. Please also see [4]\r\n * for an excellent overview of various PPM variants.\r\n *\r\n * References:\r\n * -----------\r\n *   [1] Cleary, John G. and Witten, Ian H. (1984): “Data Compression Using\r\n *       Adaptive Coding and Partial String Matching”, IEEE Transactions on\r\n *       Communications, vol. 32, no. 4, pp. 396–402.\r\n *   [2] Ward, David J. and Blackwell, Alan F. and MacKay, David J. C. (2000):\r\n *       “Dasher - A Data Entry Interface Using Continuous Gestures and\r\n *       Language Models”, UIST'00 Proceedings of the 13th annual ACM symposium\r\n *       on User interface software and technology, pp. 129–137, November, San\r\n *       Diego, USA.\r\n *   [3] Cowans, Phil (2005): “Language Modelling In Dasher -- A Tutorial”,\r\n *       June, Inference Lab, Cambridge University (presentation).\r\n *   [4] Jin Hu Huang and David Powers (2004): \"Adaptive Compression-based\r\n *       Approach for Chinese Pinyin Input.\" Proceedings of the Third SIGHAN\r\n *       Workshop on Chinese Language Processing, pp. 24--27, Barcelona, Spain,\r\n *       ACL.\r\n * Please also consult the references in README.md file in this directory.\r\n */\r\n\r\nconst assert = require(\"assert\");\r\n\r\nconst vocab = require(\"./vocabulary\");\r\n\r\n/**\r\n * Kneser-Ney \"-like\" smoothing parameters.\r\n *\r\n * These hardcoded values are copied from Dasher. Please see the documentation\r\n * for PPMLanguageModel.getProbs() below for more information.\r\n */\r\nconst knAlpha = 0.49;\r\nconst knBeta = 0.77;\r\n\r\n/* Epsilon for sanity checks. */\r\nconst epsilon = 1E-10;\r\n\r\n/**\r\n * Node in a search tree, which is implemented as a suffix trie that represents\r\n * every suffix of a sequence used during its construction. Please see\r\n *   [1] Moffat, Alistair (1990): \"Implementing the PPM data compression\r\n *       scheme\", IEEE Transactions on Communications, vol. 38, no. 11, pp.\r\n *       1917--1921.\r\n *   [2] Esko Ukknonen (1995): \"On-line construction of suffix trees\",\r\n *       Algorithmica, volume 14, pp. 249--260, Springer, 1995.\r\n *   [3] Kennington, C. (2011): \"Application of Suffix Trees as an\r\n *       Implementation Technique for Varied-Length N-gram Language Models\",\r\n *       MSc. Thesis, Saarland University.\r\n *\r\n * @final\r\n */\r\nclass Node {\r\n  constructor() {\r\n    // Leftmost child node for the current node.\r\n    this.child_ = null;\r\n    // Next node.\r\n    this.next_ = null;\r\n    // Node in the backoff structure, also known as \"vine\" structure (see [1]\r\n    // above) and \"suffix link\" (see [2] above). The backoff for the given node\r\n    // points at the node representing the shorter context. For example, if the\r\n    // current node in the trie represents string \"AA\" (corresponding to the\r\n    // branch \"[R] -> [A] -> [*A*]\" in the trie, where [R] stands for root),\r\n    // then its backoff points at the node \"A\" (represented by \"[R] ->\r\n    // [*A*]\"). In this case both nodes are in the same branch but they don't\r\n    // need to be. For example, for the node \"B\" in the trie path for the string\r\n    // \"AB\" (\"[R] -> [A] -> [*B*]\") the backoff points at the child node of a\r\n    // different path \"[R] -> [*B*]\".\r\n    this.backoff_ = null;\r\n    // Frequency count for this node. Number of times the suffix symbol stored\r\n    // in this node was observed.\r\n    this.count_ = 1;\r\n    // Symbol that this node stores.\r\n    this.symbol_ = vocab.rootSymbol;\r\n  }\r\n\r\n  /**\r\n   * Finds child of the current node with a specified symbol.\r\n   * @param {number} symbol Integer symbol.\r\n   * @return {?Node} Node with the symbol.\r\n   * @final\r\n   */\r\n  findChildWithSymbol(symbol) {\r\n    let current = this.child_;\r\n    while (current != null) {\r\n      if (current.symbol_ == symbol) {\r\n        return current;\r\n      }\r\n      current = current.next_;\r\n    }\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Total number of observations for all the children of this node. This\r\n   * counts all the events observed in this context.\r\n   *\r\n   * Note: This API is used at inference time. A possible alternative that will\r\n   * speed up the inference is to store the number of children in each node as\r\n   * originally proposed by Moffat for PPMB in\r\n   *   Moffat, Alistair (1990): \"Implementing the PPM data compression scheme\",\r\n   *   IEEE Transactions on Communications, vol. 38, no. 11, pp. 1917--1921.\r\n   * This however will increase the memory use of the algorithm which is already\r\n   * quite substantial.\r\n   *\r\n   * @param {!array} exclusionMask Boolean exclusion mask for all the symbols.\r\n   *                 Can be 'null', in which case no exclusion happens.\r\n   * @return {number} Total number of observations under this node.\r\n   * @final\r\n   */\r\n  totalChildrenCounts(exclusionMask) {\r\n    let childNode = this.child_;\r\n    let count = 0;\r\n    while (childNode != null) {\r\n      if (!exclusionMask || !exclusionMask[childNode.symbol_]) {\r\n        count += childNode.count_;\r\n      }\r\n      childNode = childNode.next_;\r\n    }\r\n    return count;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle encapsulating the search context.\r\n * @final\r\n */\r\nclass Context {\r\n  /**\r\n   * Constructor.\r\n   * @param {?Node} head Head node of the context.\r\n   * @param {number} order Length of the context.\r\n   */\r\n  constructor(head, order) {\r\n    // Current node.\r\n    this.head_ = head;\r\n    // The order corresponding to length of the context.\r\n    this.order_ = order;\r\n  }\r\n}\r\n\r\n/**\r\n * Prediction by Partial Matching (PPM) Language Model.\r\n * @final\r\n */\r\nclass PPMLanguageModel {\r\n  /**\r\n   * @param {?Vocabulary} vocab Symbol vocabulary object.\r\n   * @param {number} maxOrder Maximum length of the context.\r\n   */\r\n  constructor(vocab, maxOrder) {\r\n    this.vocab_ = vocab;\r\n    assert(this.vocab_.size() > 1,\r\n           \"Expecting at least two symbols in the vocabulary\");\r\n\r\n    this.maxOrder_ = maxOrder;\r\n    this.root_ = new Node();\r\n    this.rootContext_ = new Context();\r\n    this.rootContext_.head_ = this.root_;\r\n    this.rootContext_.order_ = 0;\r\n    this.numNodes_ = 1;\r\n\r\n    // Exclusion mechanism: Off by default, but can be enabled during the\r\n    // run-time once the constructed suffix tree contains reliable counts.\r\n    this.useExclusion_ = false;\r\n  }\r\n\r\n  /**\r\n   * Adds symbol to the supplied node.\r\n   * @param {?Node} node Tree node which to grow.\r\n   * @param {number} symbol Symbol.\r\n   * @return {?Node} Node with the symbol.\r\n   * @final @private\r\n   */\r\n  addSymbolToNode_(node, symbol) {\r\n    let symbolNode = node.findChildWithSymbol(symbol);\r\n    if (symbolNode != null) {\r\n      // Update the counts for the given node.  Only updates the counts for\r\n      // the highest order already existing node for the symbol ('single\r\n      // counting' or 'update exclusion').\r\n      symbolNode.count_++;\r\n    } else {\r\n      // Symbol does not exist under the given node. Create a new child node\r\n      // and update the backoff structure for lower contexts.\r\n      symbolNode = new Node();\r\n      symbolNode.symbol_ = symbol;\r\n      symbolNode.next_ = node.child_;\r\n      node.child_ = symbolNode;\r\n      this.numNodes_++;\r\n      if (node == this.root_) {\r\n        // Shortest possible context.\r\n        symbolNode.backoff_ = this.root_;\r\n      } else {\r\n        assert(node.backoff_ != null, \"Expected valid backoff node\");\r\n        symbolNode.backoff_ = this.addSymbolToNode_(node.backoff_, symbol);\r\n      }\r\n    }\r\n    return symbolNode;\r\n  }\r\n\r\n  /**\r\n   * Creates new context which is initially empty.\r\n   * @return {?Context} Context object.\r\n   * @final\r\n   */\r\n  createContext() {\r\n    return new Context(this.rootContext_.head_, this.rootContext_.order_);\r\n  }\r\n\r\n  /**\r\n   * Clones existing context.\r\n   * @param {?Context} context Existing context object.\r\n   * @return {?Context} Cloned context object.\r\n   * @final\r\n   */\r\n  cloneContext(context) {\r\n    return new Context(context.head_, context.order_);\r\n  }\r\n\r\n  /**\r\n   * Adds symbol to the supplied context. Does not update the model.\r\n   * @param {?Context} context Context object.\r\n   * @param {number} symbol Integer symbol.\r\n   * @final\r\n   */\r\n  addSymbolToContext(context, symbol) {\r\n    if (symbol <= vocab.rootSymbol) {  // Only add valid symbols.\r\n      return;\r\n    }\r\n    assert(symbol < this.vocab_.size(), \"Invalid symbol: \" + symbol);\r\n    while (context.head_ != null) {\r\n      if (context.order_ < this.maxOrder_) {\r\n        // Extend the current context.\r\n        const childNode = context.head_.findChildWithSymbol(symbol);\r\n        if (childNode != null) {\r\n          context.head_ = childNode;\r\n          context.order_++;\r\n          return;\r\n        }\r\n      }\r\n      // Try to extend the shorter context.\r\n      context.order_--;\r\n      context.head_ = context.head_.backoff_;\r\n    }\r\n    if (context.head_ == null) {\r\n      context.head_ = this.root_;\r\n      context.order_ = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds symbol to the supplied context and updates the model.\r\n   * @param {?Context} context Context object.\r\n   * @param {number} symbol Integer symbol.\r\n   * @final\r\n   */\r\n  addSymbolAndUpdate(context, symbol) {\r\n    if (symbol <= vocab.rootSymbol) {  // Only add valid symbols.\r\n      return;\r\n    }\r\n    assert(symbol < this.vocab_.size(), \"Invalid symbol: \" + symbol);\r\n    const symbolNode = this.addSymbolToNode_(context.head_, symbol);\r\n    assert(symbolNode == context.head_.findChildWithSymbol(symbol));\r\n    context.head_ = symbolNode;\r\n    context.order_++;\r\n    while (context.order_ > this.maxOrder_) {\r\n      context.head_ = context.head_.backoff_;\r\n      context.order_--;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns probabilities for all the symbols in the vocabulary given the\r\n   * context.\r\n   *\r\n   * Notation:\r\n   * ---------\r\n   *         $x_h$ : Context representing history, $x_{h-1}$ shorter context.\r\n   *   $n(w, x_h)$ : Count of symbol $w$ in context $x_h$.\r\n   *      $T(x_h)$ : Total count in context $x_h$.\r\n   *      $q(x_h)$ : Number of symbols with non-zero counts seen in context\r\n   *                 $x_h$, i.e. |{w' : c(x_h, w') > 0}|. Alternatively, this\r\n   *                 represents the number of distinct extensions of history\r\n   *                 $x_h$ in the training data.\r\n   *\r\n   * Standard Kneser-Ney method (aka Absolute Discounting):\r\n   * ------------------------------------------------------\r\n   * Subtracting \\beta (in [0, 1)) from all counts.\r\n   *   P_{kn}(w | x_h) = \\frac{\\max(n(w, x_h) - \\beta, 0)}{T(x_h)} +\r\n   *                     \\beta * \\frac{q(x_h)}{T(x_h)} * P_{kn}(w | x_{h-1}),\r\n   * where the second term in summation represents escaping to lower-order\r\n   * context.\r\n   *\r\n   * See: Ney, Reinhard and Kneser, Hermann (1995): “Improved backing-off for\r\n   * M-gram language modeling”, Proc. of Acoustics, Speech, and Signal\r\n   * Processing (ICASSP), May, pp. 181–184.\r\n   *\r\n   * Modified Kneser-Ney method (Dasher version [3]):\r\n   * ------------------------------------------------\r\n   * Introducing \\alpha parameter (in [0, 1)) and estimating as\r\n   *   P_{kn}(w | x_h) = \\frac{\\max(n(w, x_h) - \\beta, 0)}{T(x_h) + \\alpha} +\r\n   *                     \\frac{\\alpha + \\beta * q(x_h)}{T(x_h) + \\alpha} *\r\n   *                     P_{kn}(w | x_{h-1}) .\r\n   *\r\n   * Additional details on the above version are provided in Sections 3 and 4\r\n   * of:\r\n   *   Steinruecken, Christian and Ghahramani, Zoubin and MacKay, David (2016):\r\n   *   \"Improving PPM with dynamic parameter updates\", In Proc. Data\r\n   *   Compression Conference (DCC-2015), pp. 193--202, April, Snowbird, UT,\r\n   *   USA. IEEE.\r\n   *\r\n   * @param {?Context} context Context symbols.\r\n   * @return {?array} Array of floating point probabilities corresponding to all\r\n   *                  the symbols in the vocabulary plus the 0th element\r\n   *                  representing the root of the tree that should be ignored.\r\n   * @final\r\n   */\r\n  getProbs(context) {\r\n    // Initialize the initial estimates. Note, we don't use uniform\r\n    // distribution here.\r\n    const numSymbols = this.vocab_.size();\r\n    let probs = new Array(numSymbols);\r\n    for (let i = 0; i < numSymbols; ++i) {\r\n      probs[i] = 0.0;\r\n    }\r\n\r\n    // Initialize the exclusion mask.\r\n    let exclusionMask = null;\r\n    if (this.useExclusion_) {\r\n      exclusionMask = new Array(numSymbols);\r\n      for (let i = 0; i < numSymbols; ++i) {\r\n        exclusionMask[i] = false;\r\n      }\r\n    }\r\n\r\n    // Estimate the probabilities for all the symbols in the supplied context.\r\n    // This runs over all the symbols in the context and over all the suffixes\r\n    // (orders) of the context. If the exclusion mechanism is enabled, the\r\n    // estimate for a higher-order ngram is fully trusted and is excluded from\r\n    // further interpolation with lower-order estimates.\r\n    //\r\n    // Exclusion mechanism is disabled by default. Enable it with care: it has\r\n    // been shown to work well on large corpora, but may in theory degrade the\r\n    // performance on smaller sets (as we observed with default Dasher English\r\n    // training data).\r\n    let totalMass = 1.0;\r\n    let node = context.head_;\r\n    let gamma = totalMass;\r\n    while (node != null) {\r\n      const count = node.totalChildrenCounts(exclusionMask);\r\n      if (count > 0) {\r\n        let childNode = node.child_;\r\n        while (childNode != null) {\r\n          const symbol = childNode.symbol_;\r\n          if (!exclusionMask || !exclusionMask[symbol]) {\r\n            const p = gamma * (childNode.count_ - knBeta) / (count + knAlpha);\r\n            probs[symbol] += p;\r\n            totalMass -= p;\r\n            if (exclusionMask) {\r\n              exclusionMask[symbol] = true;\r\n            }\r\n          }\r\n          childNode = childNode.next_;\r\n        }\r\n      }\r\n\r\n      // Backoff to lower-order context. The $\\gamma$ factor represents the\r\n      // total probability mass after processing the current $n$-th order before\r\n      // backing off to $n-1$-th order. It roughly corresponds to the usual\r\n      // interpolation parameter, as used in the literature, e.g. in\r\n      //   Stanley F. Chen and Joshua Goodman (1999): \"An empirical study of\r\n      //   smoothing techniques for language modeling\", Computer Speech and\r\n      //   Language, vol. 13, pp. 359-–394.\r\n      //\r\n      // Note on computing $gamma$:\r\n      // --------------------------\r\n      // According to the PPM papers, and in particular the Section 4 of\r\n      //   Steinruecken, Christian and Ghahramani, Zoubin and MacKay,\r\n      //   David (2016): \"Improving PPM with dynamic parameter updates\", In\r\n      //   Proc. Data Compression Conference (DCC-2015), pp. 193--202, April,\r\n      //   Snowbird, UT, USA. IEEE,\r\n      // that describes blending (i.e. interpolation), the second multiplying\r\n      // factor in the interpolation $\\lambda$ for a given suffix node $x_h$ in\r\n      // the tree is given by\r\n      //   \\lambda(x_h) = \\frac{q(x_h) * \\beta + \\alpha}{T(x_h) + \\alpha} .\r\n      // It can be shown that\r\n      //   \\gamma(x_h) = 1.0 - \\sum_{w'}\r\n      //      \\frac{\\max(n(w', x_h) - \\beta, 0)}{T(x_h) + \\alpha} =\r\n      //      \\lambda(x_h)\r\n      // and, in the update below, the following is equivalent:\r\n      //   \\gamma = \\gamma * \\gamma(x_h) = totalMass .\r\n      //\r\n      // Since gamma *= (numChildren * knBeta + knAlpha) / (count + knAlpha) is\r\n      // expensive, we assign the equivalent totalMass value to gamma.\r\n      node = node.backoff_;\r\n      gamma = totalMass;\r\n    }\r\n    assert(totalMass >= 0.0,\r\n           \"Invalid remaining probability mass: \" + totalMass);\r\n\r\n    // Count the total number of symbols that should have their estimates\r\n    // blended with the uniform distribution representing the zero context.\r\n    // When exclusion mechanism is enabled (by enabling this.useExclusion_)\r\n    // this number will represent the number of symbols not seen during the\r\n    // training, otherwise, this number will be equal to total number of\r\n    // symbols because we always interpolate with the estimates for an empty\r\n    // context.\r\n    let numUnseenSymbols = 0;\r\n    for (let i = 1; i < numSymbols; ++i) {\r\n      if (!exclusionMask || !exclusionMask[i]) {\r\n        numUnseenSymbols++;\r\n      }\r\n    }\r\n\r\n    // Adjust the probability mass for all the symbols.\r\n    const remainingMass = totalMass;\r\n    for (let i = 1; i < numSymbols; ++i) {\r\n      // Following is estimated according to a uniform distribution\r\n      // corresponding to the context length of zero.\r\n      if (!exclusionMask || !exclusionMask[i]) {\r\n        const p = remainingMass / numUnseenSymbols;\r\n        probs[i] += p;\r\n        totalMass -= p;\r\n      }\r\n    }\r\n    let leftSymbols = numSymbols - 1;\r\n    let newProbMass = 0.0;\r\n    for (let i = 1; i < numSymbols; ++i) {\r\n      const p = totalMass / leftSymbols;\r\n      probs[i] += p;\r\n      totalMass -= p;\r\n      newProbMass += probs[i];\r\n      --leftSymbols;\r\n    }\r\n    assert(totalMass == 0.0, \"Expected remaining probability mass to be zero!\");\r\n    assert(Math.abs(1.0 - newProbMass) < epsilon);\r\n    return probs;\r\n  }\r\n\r\n  /**\r\n   * Prints the trie to console.\r\n   * @param {?Node} node Current trie node.\r\n   * @param {string} indent Indentation prefix.\r\n   * @final @private\r\n   */\r\n  printToConsole_(node, indent) {\r\n    console.log(indent + \"  \" + this.vocab_.symbols_[node.symbol_] +\r\n                \"(\" + node.symbol_ + \") [\" + node.count_ + \"]\");\r\n    indent += \"  \";\r\n    let child = node.child_;\r\n    while (child != null) {\r\n      this.printToConsole_(child, indent);\r\n      child = child.next_;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prints the trie to console.\r\n   * @final\r\n   */\r\n  printToConsole() {\r\n    this.printToConsole_(this.root_, \"\");\r\n  }\r\n}\r\n\r\n/**\r\n * Exported APIs.\r\n */\r\nexports.PPMLanguageModel = PPMLanguageModel;","// Copyright 2025 Will Wade\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Fuzzy matching utilities for error-tolerant prediction.\n * \n * Provides functions for calculating string similarity and filtering\n * predictions based on edit distance and other similarity metrics.\n */\n\n/**\n * Calculate Levenshtein distance between two strings.\n * @param {string} str1 First string.\n * @param {string} str2 Second string.\n * @return {number} Edit distance.\n */\nfunction levenshteinDistance(str1, str2) {\n  const len1 = str1.length;\n  const len2 = str2.length;\n  \n  // Create a 2D array for dynamic programming\n  const dp = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));\n  \n  // Initialize base cases\n  for (let i = 0; i <= len1; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= len2; j++) {\n    dp[0][j] = j;\n  }\n  \n  // Fill the dp table\n  for (let i = 1; i <= len1; i++) {\n    for (let j = 1; j <= len2; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = Math.min(\n          dp[i - 1][j] + 1,      // deletion\n          dp[i][j - 1] + 1,      // insertion\n          dp[i - 1][j - 1] + 1   // substitution\n        );\n      }\n    }\n  }\n  \n  return dp[len1][len2];\n}\n\n/**\n * Calculate similarity score between two strings (0-1, higher is more similar).\n * @param {string} str1 First string.\n * @param {string} str2 Second string.\n * @return {number} Similarity score between 0 and 1.\n */\nfunction similarityScore(str1, str2) {\n  const maxLen = Math.max(str1.length, str2.length);\n  if (maxLen === 0) return 1.0;\n  \n  const distance = levenshteinDistance(str1, str2);\n  return 1.0 - (distance / maxLen);\n}\n\n/**\n * Check if a string starts with a prefix (case-insensitive option).\n * @param {string} str The string to check.\n * @param {string} prefix The prefix to look for.\n * @param {boolean} caseSensitive Whether to do case-sensitive matching.\n * @return {boolean} True if str starts with prefix.\n */\nfunction startsWith(str, prefix, caseSensitive = true) {\n  if (!caseSensitive) {\n    str = str.toLowerCase();\n    prefix = prefix.toLowerCase();\n  }\n  return str.startsWith(prefix);\n}\n\n/**\n * Filter and rank strings by similarity to a target string.\n * @param {string} target Target string to match against.\n * @param {Array<string>} candidates Array of candidate strings.\n * @param {number} maxDistance Maximum edit distance to include.\n * @param {number} minSimilarity Minimum similarity score (0-1) to include.\n * @return {Array<{text: string, distance: number, similarity: number}>} \n *         Sorted array of matches with scores.\n */\nfunction fuzzyMatch(target, candidates, maxDistance = 2, minSimilarity = 0.5) {\n  const matches = [];\n  \n  for (const candidate of candidates) {\n    const distance = levenshteinDistance(target, candidate);\n    const similarity = similarityScore(target, candidate);\n    \n    if (distance <= maxDistance && similarity >= minSimilarity) {\n      matches.push({\n        text: candidate,\n        distance: distance,\n        similarity: similarity\n      });\n    }\n  }\n  \n  // Sort by similarity (descending) then by distance (ascending)\n  matches.sort((a, b) => {\n    if (Math.abs(a.similarity - b.similarity) > 0.001) {\n      return b.similarity - a.similarity;\n    }\n    return a.distance - b.distance;\n  });\n  \n  return matches;\n}\n\n/**\n * Get keyboard adjacency map for QWERTY layout.\n * Used for keyboard-proximity-based error tolerance.\n * @return {Object} Map of characters to their adjacent keys.\n */\nfunction getQwertyAdjacency() {\n  return {\n    'q': ['w', 'a', 's'],\n    'w': ['q', 'e', 'a', 's', 'd'],\n    'e': ['w', 'r', 's', 'd', 'f'],\n    'r': ['e', 't', 'd', 'f', 'g'],\n    't': ['r', 'y', 'f', 'g', 'h'],\n    'y': ['t', 'u', 'g', 'h', 'j'],\n    'u': ['y', 'i', 'h', 'j', 'k'],\n    'i': ['u', 'o', 'j', 'k', 'l'],\n    'o': ['i', 'p', 'k', 'l'],\n    'p': ['o', 'l'],\n    'a': ['q', 'w', 's', 'z', 'x'],\n    's': ['q', 'w', 'e', 'a', 'd', 'z', 'x', 'c'],\n    'd': ['w', 'e', 'r', 's', 'f', 'x', 'c', 'v'],\n    'f': ['e', 'r', 't', 'd', 'g', 'c', 'v', 'b'],\n    'g': ['r', 't', 'y', 'f', 'h', 'v', 'b', 'n'],\n    'h': ['t', 'y', 'u', 'g', 'j', 'b', 'n', 'm'],\n    'j': ['y', 'u', 'i', 'h', 'k', 'n', 'm'],\n    'k': ['u', 'i', 'o', 'j', 'l', 'm'],\n    'l': ['i', 'o', 'p', 'k'],\n    'z': ['a', 's', 'x'],\n    'x': ['a', 's', 'd', 'z', 'c'],\n    'c': ['s', 'd', 'f', 'x', 'v'],\n    'v': ['d', 'f', 'g', 'c', 'b'],\n    'b': ['f', 'g', 'h', 'v', 'n'],\n    'n': ['g', 'h', 'j', 'b', 'm'],\n    'm': ['h', 'j', 'k', 'n']\n  };\n}\n\n/**\n * Check if two characters are adjacent on a QWERTY keyboard.\n * @param {string} char1 First character.\n * @param {string} char2 Second character.\n * @return {boolean} True if characters are adjacent.\n */\nfunction areKeysAdjacent(char1, char2) {\n  const adjacency = getQwertyAdjacency();\n  const c1 = char1.toLowerCase();\n  const c2 = char2.toLowerCase();\n  \n  return adjacency[c1] && adjacency[c1].includes(c2);\n}\n\n/**\n * Calculate keyboard-aware edit distance.\n * Substitutions between adjacent keys cost less than non-adjacent keys.\n * @param {string} str1 First string.\n * @param {string} str2 Second string.\n * @return {number} Keyboard-aware edit distance.\n */\nfunction keyboardAwareDistance(str1, str2) {\n  const len1 = str1.length;\n  const len2 = str2.length;\n  \n  const dp = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));\n  \n  for (let i = 0; i <= len1; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= len2; j++) {\n    dp[0][j] = j;\n  }\n  \n  for (let i = 1; i <= len1; i++) {\n    for (let j = 1; j <= len2; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        // Check if keys are adjacent for substitution cost\n        const substCost = areKeysAdjacent(str1[i - 1], str2[j - 1]) ? 0.5 : 1.0;\n        \n        dp[i][j] = Math.min(\n          dp[i - 1][j] + 1,              // deletion\n          dp[i][j - 1] + 1,              // insertion\n          dp[i - 1][j - 1] + substCost   // substitution\n        );\n      }\n    }\n  }\n  \n  return dp[len1][len2];\n}\n\n/**\n * Exported APIs.\n */\nexports.levenshteinDistance = levenshteinDistance;\nexports.similarityScore = similarityScore;\nexports.startsWith = startsWith;\nexports.fuzzyMatch = fuzzyMatch;\nexports.getQwertyAdjacency = getQwertyAdjacency;\nexports.areKeysAdjacent = areKeysAdjacent;\nexports.keyboardAwareDistance = keyboardAwareDistance;\n\n","// Copyright 2025 Will Wade\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Word tokenization utilities.\n * \n * Provides functions for splitting text into words and handling\n * word boundaries for prediction.\n */\n\n/**\n * Tokenize text into words.\n * @param {string} text Text to tokenize.\n * @return {Array<string>} Array of words.\n */\nfunction tokenize(text) {\n  if (!text || typeof text !== 'string') {\n    return [];\n  }\n  \n  // Split on whitespace and punctuation, but keep the tokens\n  return text.trim().split(/\\s+/).filter(word => word.length > 0);\n}\n\n/**\n * Get the last partial word from text (for word completion).\n * @param {string} text Input text.\n * @return {string} The last partial word.\n */\nfunction getLastPartialWord(text) {\n  if (!text || typeof text !== 'string') {\n    return '';\n  }\n  \n  const trimmed = text.trimEnd();\n  const words = trimmed.split(/\\s+/);\n  \n  // If text ends with whitespace, there's no partial word\n  if (text !== trimmed) {\n    return '';\n  }\n  \n  return words[words.length - 1] || '';\n}\n\n/**\n * Get the context (all words except the last partial word).\n * @param {string} text Input text.\n * @return {string} Context text.\n */\nfunction getContext(text) {\n  if (!text || typeof text !== 'string') {\n    return '';\n  }\n  \n  const trimmed = text.trimEnd();\n  const words = trimmed.split(/\\s+/);\n  \n  // If text ends with whitespace, all words are context\n  if (text !== trimmed) {\n    return trimmed;\n  }\n  \n  // Otherwise, exclude the last word\n  if (words.length <= 1) {\n    return '';\n  }\n  \n  return words.slice(0, -1).join(' ');\n}\n\n/**\n * Check if text ends with a word boundary (whitespace).\n * @param {string} text Input text.\n * @return {boolean} True if text ends with whitespace.\n */\nfunction endsWithWordBoundary(text) {\n  if (!text || typeof text !== 'string') {\n    return true;\n  }\n  \n  return text !== text.trimEnd();\n}\n\n/**\n * Normalize text for prediction (lowercase, trim).\n * @param {string} text Input text.\n * @param {boolean} lowercase Whether to convert to lowercase.\n * @return {string} Normalized text.\n */\nfunction normalize(text, lowercase = true) {\n  if (!text || typeof text !== 'string') {\n    return '';\n  }\n  \n  let normalized = text.trim();\n  if (lowercase) {\n    normalized = normalized.toLowerCase();\n  }\n  \n  return normalized;\n}\n\n/**\n * Split text into characters, handling special cases.\n * @param {string} text Input text.\n * @return {Array<string>} Array of characters.\n */\nfunction toCharArray(text) {\n  if (!text || typeof text !== 'string') {\n    return [];\n  }\n  \n  return Array.from(text);\n}\n\n/**\n * Join an array of characters into a string.\n * @param {Array<string>} chars Array of characters.\n * @return {string} Joined string.\n */\nfunction fromCharArray(chars) {\n  if (!Array.isArray(chars)) {\n    return '';\n  }\n  \n  return chars.join('');\n}\n\n/**\n * Get n-grams from text.\n * @param {string} text Input text.\n * @param {number} n Size of n-grams.\n * @return {Array<string>} Array of n-grams.\n */\nfunction getNgrams(text, n) {\n  if (!text || typeof text !== 'string' || n < 1) {\n    return [];\n  }\n  \n  const chars = toCharArray(text);\n  const ngrams = [];\n  \n  for (let i = 0; i <= chars.length - n; i++) {\n    ngrams.push(chars.slice(i, i + n).join(''));\n  }\n  \n  return ngrams;\n}\n\n/**\n * Remove punctuation from text.\n * @param {string} text Input text.\n * @return {string} Text without punctuation.\n */\nfunction removePunctuation(text) {\n  if (!text || typeof text !== 'string') {\n    return '';\n  }\n  \n  return text.replace(/[^\\w\\s]/g, '');\n}\n\n/**\n * Check if a character is alphanumeric.\n * @param {string} char Character to check.\n * @return {boolean} True if alphanumeric.\n */\nfunction isAlphanumeric(char) {\n  if (!char || typeof char !== 'string' || char.length !== 1) {\n    return false;\n  }\n  \n  return /^[a-zA-Z0-9]$/.test(char);\n}\n\n/**\n * Check if a character is whitespace.\n * @param {string} char Character to check.\n * @return {boolean} True if whitespace.\n */\nfunction isWhitespace(char) {\n  if (!char || typeof char !== 'string' || char.length !== 1) {\n    return false;\n  }\n  \n  return /^\\s$/.test(char);\n}\n\n/**\n * Exported APIs.\n */\nexports.tokenize = tokenize;\nexports.getLastPartialWord = getLastPartialWord;\nexports.getContext = getContext;\nexports.endsWithWordBoundary = endsWithWordBoundary;\nexports.normalize = normalize;\nexports.toCharArray = toCharArray;\nexports.fromCharArray = fromCharArray;\nexports.getNgrams = getNgrams;\nexports.removePunctuation = removePunctuation;\nexports.isAlphanumeric = isAlphanumeric;\nexports.isWhitespace = isWhitespace;\n\n","// Copyright 2025 Will Wade\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview High-level prediction API wrapping PPM language model.\n * \n * Provides word and letter prediction with configurable error tolerance.\n */\n\nconst ppm = require('./ppm_language_model');\nconst vocab = require('./vocabulary');\nconst fuzzy = require('./utils/fuzzy-matcher');\nconst tokenizer = require('./utils/word-tokenizer');\n\n/**\n * Configuration options for the predictor.\n * @typedef {Object} PredictorConfig\n * @property {number} maxOrder - Maximum context length for PPM (default: 5)\n * @property {boolean} errorTolerant - Enable error-tolerant mode (default: false)\n * @property {number} maxEditDistance - Maximum edit distance for fuzzy matching (default: 2)\n * @property {number} minSimilarity - Minimum similarity score 0-1 (default: 0.5)\n * @property {boolean} keyboardAware - Use keyboard-aware distance (default: false)\n * @property {boolean} caseSensitive - Case-sensitive matching (default: false)\n * @property {number} maxPredictions - Maximum number of predictions to return (default: 10)\n * @property {boolean} adaptive - Update model as text is entered (default: false)\n * @property {Array<string>} lexicon - Optional word list for word prediction\n */\n\n/**\n * Prediction result.\n * @typedef {Object} Prediction\n * @property {string} text - Predicted text\n * @property {number} probability - Probability score (0-1)\n * @property {number} [distance] - Edit distance (only in error-tolerant mode)\n * @property {number} [similarity] - Similarity score (only in error-tolerant mode)\n */\n\n/**\n * Predictor class providing word and letter prediction.\n */\nclass Predictor {\n  /**\n   * Constructor.\n   * @param {PredictorConfig} config Configuration options.\n   */\n  constructor(config = {}) {\n    // Set default configuration\n    this.config = {\n      maxOrder: config.maxOrder || 5,\n      errorTolerant: config.errorTolerant !== undefined ? config.errorTolerant : false,\n      maxEditDistance: config.maxEditDistance || 2,\n      minSimilarity: config.minSimilarity || 0.5,\n      keyboardAware: config.keyboardAware !== undefined ? config.keyboardAware : false,\n      caseSensitive: config.caseSensitive !== undefined ? config.caseSensitive : false,\n      maxPredictions: config.maxPredictions || 10,\n      adaptive: config.adaptive !== undefined ? config.adaptive : false,\n      lexicon: config.lexicon || []\n    };\n\n    // Create vocabulary\n    this.vocab = new vocab.Vocabulary();\n    \n    // Add all printable ASCII characters to vocabulary\n    for (let i = 32; i <= 126; i++) {\n      this.vocab.addSymbol(String.fromCharCode(i));\n    }\n    \n    // Add common special characters\n    this.vocab.addSymbol('\\n');\n    this.vocab.addSymbol('\\t');\n    \n    // Create PPM language model\n    this.model = new ppm.PPMLanguageModel(this.vocab, this.config.maxOrder);\n    \n    // Create context\n    this.context = this.model.createContext();\n    \n    // Build lexicon index if provided\n    this.lexiconIndex = new Set(this.config.lexicon.map(word => \n      this.config.caseSensitive ? word : word.toLowerCase()\n    ));\n  }\n\n  /**\n   * Train the model on text.\n   * @param {string} text Training text.\n   */\n  train(text) {\n    if (!text || typeof text !== 'string') {\n      return;\n    }\n\n    const chars = tokenizer.toCharArray(text);\n    const context = this.model.createContext();\n    \n    for (const char of chars) {\n      const symbolId = this.vocab.addSymbol(char);\n      this.model.addSymbolAndUpdate(context, symbolId);\n    }\n  }\n\n  /**\n   * Reset the prediction context.\n   */\n  resetContext() {\n    this.context = this.model.createContext();\n  }\n\n  /**\n   * Add text to the current context.\n   * @param {string} text Text to add to context.\n   * @param {boolean} update Whether to update the model (adaptive mode).\n   */\n  addToContext(text, update = null) {\n    if (!text || typeof text !== 'string') {\n      return;\n    }\n\n    const shouldUpdate = update !== null ? update : this.config.adaptive;\n    const chars = tokenizer.toCharArray(text);\n    \n    for (const char of chars) {\n      let symbolId = this.vocab.symbols_.indexOf(char);\n      if (symbolId < 0) {\n        symbolId = this.vocab.addSymbol(char);\n      }\n      \n      if (shouldUpdate) {\n        this.model.addSymbolAndUpdate(this.context, symbolId);\n      } else {\n        this.model.addSymbolToContext(this.context, symbolId);\n      }\n    }\n  }\n\n  /**\n   * Get character/letter predictions.\n   * @param {string} context Optional context string (uses current context if not provided).\n   * @return {Array<Prediction>} Array of character predictions.\n   */\n  predictNextCharacter(context = null) {\n    let workingContext = this.context;\n    \n    if (context !== null) {\n      workingContext = this.model.createContext();\n      const chars = tokenizer.toCharArray(context);\n      for (const char of chars) {\n        let symbolId = this.vocab.symbols_.indexOf(char);\n        if (symbolId < 0) {\n          symbolId = this.vocab.addSymbol(char);\n        }\n        this.model.addSymbolToContext(workingContext, symbolId);\n      }\n    }\n\n    // Get probabilities from PPM model\n    const probs = this.model.getProbs(workingContext);\n    \n    // Convert to predictions array\n    const predictions = [];\n    for (let i = 1; i < probs.length; i++) {\n      if (probs[i] > 0) {\n        predictions.push({\n          text: this.vocab.symbols_[i],\n          probability: probs[i]\n        });\n      }\n    }\n    \n    // Sort by probability (descending)\n    predictions.sort((a, b) => b.probability - a.probability);\n    \n    // Return top N predictions\n    return predictions.slice(0, this.config.maxPredictions);\n  }\n\n  /**\n   * Get word completion predictions.\n   * @param {string} partialWord Partial word to complete.\n   * @param {string} precedingContext Optional preceding context.\n   * @return {Array<Prediction>} Array of word predictions.\n   */\n  predictWordCompletion(partialWord, precedingContext = '') {\n    if (!partialWord || typeof partialWord !== 'string') {\n      return [];\n    }\n\n    const normalized = this.config.caseSensitive ? partialWord : partialWord.toLowerCase();\n    \n    // If we have a lexicon, use it for word completion\n    if (this.lexiconIndex.size > 0) {\n      return this._predictFromLexicon(normalized, precedingContext);\n    }\n    \n    // Otherwise, use character-level prediction to build word completions\n    return this._predictCharacterBased(partialWord, precedingContext);\n  }\n\n  /**\n   * Predict word completions from lexicon.\n   * @param {string} partialWord Partial word (normalized).\n   * @param {string} precedingContext Preceding context.\n   * @return {Array<Prediction>} Array of word predictions.\n   * @private\n   */\n  _predictFromLexicon(partialWord, precedingContext) {\n    const candidates = [];\n    \n    // Find all words in lexicon that start with the partial word\n    for (const word of this.lexiconIndex) {\n      if (fuzzy.startsWith(word, partialWord, this.config.caseSensitive)) {\n        candidates.push(word);\n      }\n    }\n    \n    // In error-tolerant mode, also include fuzzy matches\n    if (this.config.errorTolerant && partialWord.length >= 2) {\n      const fuzzyMatches = fuzzy.fuzzyMatch(\n        partialWord,\n        Array.from(this.lexiconIndex),\n        this.config.maxEditDistance,\n        this.config.minSimilarity\n      );\n      \n      for (const match of fuzzyMatches) {\n        if (!candidates.includes(match.text)) {\n          candidates.push(match.text);\n        }\n      }\n    }\n    \n    // Score candidates using PPM model\n    return this._scoreCandidates(candidates, precedingContext);\n  }\n\n  /**\n   * Predict word completions using character-level model.\n   * @param {string} partialWord Partial word.\n   * @param {string} precedingContext Preceding context.\n   * @return {Array<Prediction>} Array of word predictions.\n   * @private\n   */\n  _predictCharacterBased(partialWord, precedingContext) {\n    const predictions = [];\n    const maxLength = 20; // Maximum word length to predict\n    \n    // Create a context with the preceding text and partial word\n    const fullContext = precedingContext + partialWord;\n    const workingContext = this.model.createContext();\n    \n    const chars = tokenizer.toCharArray(fullContext);\n    for (const char of chars) {\n      let symbolId = this.vocab.symbols_.indexOf(char);\n      if (symbolId >= 0) {\n        this.model.addSymbolToContext(workingContext, symbolId);\n      }\n    }\n    \n    // Generate completions by predicting next characters\n    const completions = this._generateCompletions(\n      workingContext,\n      partialWord,\n      maxLength - partialWord.length,\n      5 // Generate top 5 completions\n    );\n    \n    for (const completion of completions) {\n      predictions.push({\n        text: completion.text,\n        probability: completion.probability\n      });\n    }\n    \n    return predictions;\n  }\n\n  /**\n   * Generate word completions by predicting next characters.\n   * @param {Object} context PPM context.\n   * @param {string} prefix Current prefix.\n   * @param {number} maxChars Maximum characters to add.\n   * @param {number} numCompletions Number of completions to generate.\n   * @return {Array<Prediction>} Generated completions.\n   * @private\n   */\n  _generateCompletions(context, prefix, maxChars, numCompletions) {\n    const completions = [];\n    const spaceId = this.vocab.symbols_.indexOf(' ');\n    \n    // Simple beam search\n    let beams = [{ context: this.model.cloneContext(context), text: prefix, prob: 1.0 }];\n    \n    for (let i = 0; i < maxChars; i++) {\n      const newBeams = [];\n      \n      for (const beam of beams) {\n        const probs = this.model.getProbs(beam.context);\n        const topChars = [];\n        \n        // Get top characters\n        for (let j = 1; j < probs.length; j++) {\n          if (probs[j] > 0) {\n            topChars.push({ id: j, prob: probs[j] });\n          }\n        }\n        \n        topChars.sort((a, b) => b.prob - a.prob);\n        \n        // Expand beam with top characters\n        for (let k = 0; k < Math.min(3, topChars.length); k++) {\n          const charId = topChars[k].id;\n          const char = this.vocab.symbols_[charId];\n          \n          // Stop at space or newline\n          if (charId === spaceId || char === '\\n') {\n            if (beam.text.length > prefix.length) {\n              completions.push({ text: beam.text, probability: beam.prob });\n            }\n            continue;\n          }\n          \n          const newContext = this.model.cloneContext(beam.context);\n          this.model.addSymbolToContext(newContext, charId);\n          \n          newBeams.push({\n            context: newContext,\n            text: beam.text + char,\n            prob: beam.prob * topChars[k].prob\n          });\n        }\n      }\n      \n      if (newBeams.length === 0) break;\n      \n      // Keep top beams\n      newBeams.sort((a, b) => b.prob - a.prob);\n      beams = newBeams.slice(0, numCompletions);\n    }\n    \n    // Add remaining beams as completions\n    for (const beam of beams) {\n      if (beam.text.length > prefix.length) {\n        completions.push({ text: beam.text, probability: beam.prob });\n      }\n    }\n    \n    completions.sort((a, b) => b.probability - a.probability);\n    return completions.slice(0, numCompletions);\n  }\n\n  /**\n   * Score candidate words using the PPM model.\n   * @param {Array<string>} candidates Candidate words.\n   * @param {string} precedingContext Preceding context.\n   * @return {Array<Prediction>} Scored predictions.\n   * @private\n   */\n  _scoreCandidates(candidates, precedingContext) {\n    const predictions = [];\n    \n    for (const candidate of candidates) {\n      const score = this._scoreWord(candidate, precedingContext);\n      predictions.push({\n        text: candidate,\n        probability: score\n      });\n    }\n    \n    predictions.sort((a, b) => b.probability - a.probability);\n    return predictions.slice(0, this.config.maxPredictions);\n  }\n\n  /**\n   * Score a word using the PPM model.\n   * @param {string} word Word to score.\n   * @param {string} precedingContext Preceding context.\n   * @return {number} Score (probability).\n   * @private\n   */\n  _scoreWord(word, precedingContext) {\n    const fullText = precedingContext + word;\n    const workingContext = this.model.createContext();\n    \n    let logProb = 0;\n    const chars = tokenizer.toCharArray(fullText);\n    \n    for (const char of chars) {\n      const symbolId = this.vocab.symbols_.indexOf(char);\n      if (symbolId >= 0) {\n        const probs = this.model.getProbs(workingContext);\n        const prob = probs[symbolId] || 1e-10;\n        logProb += Math.log(prob);\n        this.model.addSymbolToContext(workingContext, symbolId);\n      }\n    }\n    \n    // Convert log probability to probability (normalized)\n    return Math.exp(logProb / chars.length);\n  }\n\n  /**\n   * Get configuration.\n   * @return {PredictorConfig} Current configuration.\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration.\n   * @param {Partial<PredictorConfig>} newConfig Configuration updates.\n   */\n  updateConfig(newConfig) {\n    this.config = { ...this.config, ...newConfig };\n    \n    // Rebuild lexicon index if lexicon changed\n    if (newConfig.lexicon) {\n      this.lexiconIndex = new Set(this.config.lexicon.map(word => \n        this.config.caseSensitive ? word : word.toLowerCase()\n      ));\n    }\n  }\n}\n\n/**\n * Exported APIs.\n */\nexports.Predictor = Predictor;\n\n","// Copyright 2025 Will Wade\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Browser-compatible entry point for noisy-channel-predictor.\n * \n * This version excludes Node.js-specific dependencies (like fs) and provides\n * a browser-friendly API.\n */\n\nconst predictorModule = require('./predictor');\nconst ppmModule = require('./ppm_language_model');\nconst vocabModule = require('./vocabulary');\nconst fuzzyMatcher = require('./utils/fuzzy-matcher');\nconst wordTokenizer = require('./utils/word-tokenizer');\n\n// Extract the actual classes from the modules\nconst Predictor = predictorModule.Predictor || predictorModule;\nconst PPMLanguageModel = ppmModule.PPMLanguageModel || ppmModule;\nconst Vocabulary = vocabModule.Vocabulary || vocabModule;\n\n/**\n * Create a new predictor instance.\n * \n * @param {Object} config - Configuration options\n * @returns {Predictor} Predictor instance\n */\nfunction createPredictor(config = {}) {\n  return new Predictor(config);\n}\n\n/**\n * Create a predictor with strict mode (exact matching only).\n * \n * @param {Object} config - Configuration options\n * @returns {Predictor} Predictor instance\n */\nfunction createStrictPredictor(config = {}) {\n  return new Predictor({\n    ...config,\n    errorTolerant: false\n  });\n}\n\n/**\n * Create a predictor with error-tolerant mode enabled.\n * \n * @param {Object} config - Configuration options\n * @returns {Predictor} Predictor instance\n */\nfunction createErrorTolerantPredictor(config = {}) {\n  return new Predictor({\n    ...config,\n    errorTolerant: true\n  });\n}\n\n// Export for different module systems\nconst PPMPredictor = {\n  // Factory functions\n  createPredictor,\n  createStrictPredictor,\n  createErrorTolerantPredictor,\n\n  // Classes\n  Predictor,\n  PPMLanguageModel,\n  Vocabulary,\n\n  // Utilities\n  fuzzyMatcher,\n  wordTokenizer,\n\n  // Convenience exports\n  levenshteinDistance: fuzzyMatcher.levenshteinDistance,\n  similarityScore: fuzzyMatcher.similarityScore,\n  fuzzyMatch: fuzzyMatcher.fuzzyMatch\n};\n\n// UMD export\nif (typeof module !== 'undefined' && module.exports) {\n  // CommonJS\n  module.exports = PPMPredictor;\n  module.exports.createPredictor = createPredictor;\n  module.exports.createStrictPredictor = createStrictPredictor;\n  module.exports.createErrorTolerantPredictor = createErrorTolerantPredictor;\n  module.exports.Predictor = Predictor;\n  module.exports.PPMLanguageModel = PPMLanguageModel;\n  module.exports.Vocabulary = Vocabulary;\n  module.exports.fuzzyMatcher = fuzzyMatcher;\n  module.exports.wordTokenizer = wordTokenizer;\n  module.exports.levenshteinDistance = fuzzyMatcher.levenshteinDistance;\n  module.exports.similarityScore = fuzzyMatcher.similarityScore;\n  module.exports.fuzzyMatch = fuzzyMatcher.fuzzyMatch;\n}\n\nif (typeof window !== 'undefined') {\n  // Browser global\n  window.PPMPredictor = PPMPredictor;\n}\n\n// Default export\nmodule.exports = PPMPredictor;\n\n","import { getDefaultExportFromCjs } from \"\u0000commonjsHelpers.js\";\nimport { __require as requireIndex_browser } from \"C:\\\\Users\\\\admin.will\\\\Documents\\\\GitHub\\\\noisy-channel-correction\\\\js\\\\src\\\\index.browser.js\";\nvar index_browserExports = requireIndex_browser();\nexport { index_browserExports as __moduleExports };\nexport default /*@__PURE__*/getDefaultExportFromCjs(index_browserExports);"],"names":["require$$1","require$$0","require$$2","require$$3","require$$4"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CACuB,SAAS,MAAM,CAAC,SAAS,EAAE,OAAO,EAAE;CAC3D,UAAU,IAAI,CAAC,SAAS,EAAE;CAC1B,YAAY,MAAM,IAAI,KAAK,CAAC,OAAO,IAAI,kBAAkB,CAAC;CAC1D,UAAU;CACV,QAAQ;;;;;;;;;;;;;;;;CCLR;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;EACA,MAAM,UAAU,GAAG,CAAC,CAAC;AACrB;CACA;EACA,MAAM,cAAc,GAAG,KAAK,CAAC;AAC7B;CACA;EACA,MAAM,SAAS,GAAG,OAAO,CAAC;AAC1B;CACA;CACA;CACA;CACA;CACA;CACA,CAAA,MAAM,UAAU,CAAC;CACjB,GAAE,WAAW,GAAG;CAChB,KAAI,IAAI,CAAC,QAAQ,GAAG,KAAK,EAAE,CAAC;MACxB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;CACvC,KAAI,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;IACzB,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA;IACE,SAAS,CAAC,MAAM,EAAE;MAChB,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;CAC5C,KAAI,IAAI,GAAG,IAAI,CAAC,EAAE;QACZ,OAAO,GAAG,CAAC;MACjB,CAAK;CACL;CACA;CACA;MACI,MAAM,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;MACvC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;MAC3B,OAAO,SAAS,CAAC;IACrB,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;IACE,cAAc,CAAC,MAAM,EAAE;MACrB,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;CAC5C,KAAI,IAAI,GAAG,IAAI,CAAC,EAAE;QACZ,OAAO,GAAG,CAAC;MACjB,CAAK;MACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;CAChD,KAAI,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA,GAAE,IAAI,GAAG;CACT,KAAI,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;IAChC,CAAG;GACF;AACD;CACA;CACA;CACA;CACA,CAAA,UAAA,CAAA,UAAkB,GAAG,UAAU,CAAC;CAChC,CAAA,UAAA,CAAA,UAAkB,GAAG,UAAU;;;;;;;;;CC3F/B;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;EACA,MAAM,MAAM,GAAG,UAAiB,CAAC;AACjC;EACA,MAAM,KAAK,GAAGA,iBAAA,EAAuB,CAAC;AACtC;CACA;CACA;CACA;CACA;CACA;CACA;EACA,MAAM,OAAO,GAAG,IAAI,CAAC;EACrB,MAAM,MAAM,GAAG,IAAI,CAAC;AACpB;CACA;EACA,MAAM,OAAO,GAAG,KAAK,CAAC;AACtB;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA,CAAA,MAAM,IAAI,CAAC;CACX,GAAE,WAAW,GAAG;CAChB;CACA,KAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;CACvB;CACA,KAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;CACtB;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA,KAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;CACzB;CACA;CACA,KAAI,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;CACpB;CACA,KAAI,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,UAAU,CAAC;IACpC,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA;IACE,mBAAmB,CAAC,MAAM,EAAE;CAC9B,KAAI,IAAI,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC;CAC9B,KAAI,OAAO,OAAO,IAAI,IAAI,EAAE;CAC5B,OAAM,IAAI,OAAO,CAAC,OAAO,IAAI,MAAM,EAAE;UAC7B,OAAO,OAAO,CAAC;QACvB,CAAO;CACP,OAAM,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC;MAC9B,CAAK;MACD,OAAO,OAAO,CAAC;IACnB,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;IACE,mBAAmB,CAAC,aAAa,EAAE;CACrC,KAAI,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC;CAChC,KAAI,IAAI,KAAK,GAAG,CAAC,CAAC;CAClB,KAAI,OAAO,SAAS,IAAI,IAAI,EAAE;QACxB,IAAI,CAAC,aAAa,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE;CAC/D,SAAQ,KAAK,IAAI,SAAS,CAAC,MAAM,CAAC;QAClC,CAAO;CACP,OAAM,SAAS,GAAG,SAAS,CAAC,KAAK,CAAC;MAClC,CAAK;MACD,OAAO,KAAK,CAAC;IACjB,CAAG;GACF;AACD;CACA;CACA;CACA;CACA;CACA,CAAA,MAAM,OAAO,CAAC;CACd;CACA;CACA;CACA;CACA;CACA,GAAE,WAAW,CAAC,IAAI,EAAE,KAAK,EAAE;CAC3B;CACA,KAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;CACtB;CACA,KAAI,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;IACxB,CAAG;GACF;AACD;CACA;CACA;CACA;CACA;CACA,CAAA,MAAM,gBAAgB,CAAC;CACvB;CACA;CACA;CACA;CACA,GAAE,WAAW,CAAC,KAAK,EAAE,QAAQ,EAAE;CAC/B,KAAI,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;MACpB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC;aACtB,kDAAkD,CAAC,CAAC;AAC/D;CACA,KAAI,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;CAC9B,KAAI,IAAI,CAAC,KAAK,GAAG,IAAI,IAAI,EAAE,CAAC;CAC5B,KAAI,IAAI,CAAC,YAAY,GAAG,IAAI,OAAO,EAAE,CAAC;MAClC,IAAI,CAAC,YAAY,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;CACzC,KAAI,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC;CACjC,KAAI,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;AACvB;CACA;CACA;CACA,KAAI,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;IAC/B,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA,GAAE,gBAAgB,CAAC,IAAI,EAAE,MAAM,EAAE;MAC7B,IAAI,UAAU,GAAG,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;CACtD,KAAI,IAAI,UAAU,IAAI,IAAI,EAAE;CAC5B;CACA;CACA;CACA,OAAM,UAAU,CAAC,MAAM,EAAE,CAAC;CAC1B,KAAA,CAAK,MAAM;CACX;CACA;CACA,OAAM,UAAU,GAAG,IAAI,IAAI,EAAE,CAAC;CAC9B,OAAM,UAAU,CAAC,OAAO,GAAG,MAAM,CAAC;CAClC,OAAM,UAAU,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;CACrC,OAAM,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC;CAC/B,OAAM,IAAI,CAAC,SAAS,EAAE,CAAC;CACvB,OAAM,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE;CAC9B;CACA,SAAQ,UAAU,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;CACzC,OAAA,CAAO,MAAM;UACL,MAAM,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,EAAE,6BAA6B,CAAC,CAAC;CACrE,SAAQ,UAAU,CAAC,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAC3E,CAAO;MACP,CAAK;MACD,OAAO,UAAU,CAAC;IACtB,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA,GAAE,aAAa,GAAG;CAClB,KAAI,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IAC1E,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA;IACE,YAAY,CAAC,OAAO,EAAE;CACxB,KAAI,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;IACtD,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA;CACA,GAAE,kBAAkB,CAAC,OAAO,EAAE,MAAM,EAAE;CACtC,KAAI,IAAI,MAAM,IAAI,KAAK,CAAC,UAAU,EAAE;CACpC,OAAM,OAAO;MACb,CAAK;CACL,KAAI,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,kBAAkB,GAAG,MAAM,CAAC,CAAC;CACrE,KAAI,OAAO,OAAO,CAAC,KAAK,IAAI,IAAI,EAAE;QAC5B,IAAI,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE;CAC3C;UACQ,MAAM,SAAS,GAAG,OAAO,CAAC,KAAK,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;CACpE,SAAQ,IAAI,SAAS,IAAI,IAAI,EAAE;CAC/B,WAAU,OAAO,CAAC,KAAK,GAAG,SAAS,CAAC;CACpC,WAAU,OAAO,CAAC,MAAM,EAAE,CAAC;CAC3B,WAAU,OAAO;UACjB,CAAS;QACT,CAAO;CACP;CACA,OAAM,OAAO,CAAC,MAAM,EAAE,CAAC;QACjB,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC;MAC7C,CAAK;CACL,KAAI,IAAI,OAAO,CAAC,KAAK,IAAI,IAAI,EAAE;CAC/B,OAAM,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;CACjC,OAAM,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;MACzB,CAAK;IACL,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA;CACA,GAAE,kBAAkB,CAAC,OAAO,EAAE,MAAM,EAAE;CACtC,KAAI,IAAI,MAAM,IAAI,KAAK,CAAC,UAAU,EAAE;CACpC,OAAM,OAAO;MACb,CAAK;CACL,KAAI,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,kBAAkB,GAAG,MAAM,CAAC,CAAC;CACrE,KAAI,MAAM,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;CACpE,KAAI,MAAM,CAAC,UAAU,IAAI,OAAO,CAAC,KAAK,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC,CAAC;CACpE,KAAI,OAAO,CAAC,KAAK,GAAG,UAAU,CAAC;CAC/B,KAAI,OAAO,CAAC,MAAM,EAAE,CAAC;MACjB,OAAO,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE;QACtC,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC;CAC7C,OAAM,OAAO,CAAC,MAAM,EAAE,CAAC;MACvB,CAAK;IACL,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;IACE,QAAQ,CAAC,OAAO,EAAE;CACpB;CACA;MACI,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;MACtC,IAAI,KAAK,GAAG,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC;CACtC,KAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE;CACzC,OAAM,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;MACrB,CAAK;AACL;CACA;CACA,KAAI,IAAI,aAAa,GAAG,IAAI,CAAC;CAC7B,KAAI,IAAI,IAAI,CAAC,aAAa,EAAE;CAC5B,OAAM,aAAa,GAAG,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC;CAC5C,OAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE;CAC3C,SAAQ,aAAa,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;QACjC,CAAO;MACP,CAAK;AACL;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA,KAAI,IAAI,SAAS,GAAG,GAAG,CAAC;CACxB,KAAI,IAAI,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC;CAC7B,KAAI,IAAI,KAAK,GAAG,SAAS,CAAC;CAC1B,KAAI,OAAO,IAAI,IAAI,IAAI,EAAE;QACnB,MAAM,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;CAC5D,OAAM,IAAI,KAAK,GAAG,CAAC,EAAE;CACrB,SAAQ,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC;CACpC,SAAQ,OAAO,SAAS,IAAI,IAAI,EAAE;CAClC,WAAU,MAAM,MAAM,GAAG,SAAS,CAAC,OAAO,CAAC;YACjC,IAAI,CAAC,aAAa,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE;CACxD,aAAY,MAAM,CAAC,GAAG,KAAK,IAAI,SAAS,CAAC,MAAM,GAAG,MAAM,CAAC,IAAI,KAAK,GAAG,OAAO,CAAC,CAAC;CAC9E,aAAY,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;cACnB,SAAS,IAAI,CAAC,CAAC;cACf,IAAI,aAAa,EAAE;CAC/B,eAAc,aAAa,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;cAC3C,CAAa;YACb,CAAW;CACX,WAAU,SAAS,GAAG,SAAS,CAAC,KAAK,CAAC;UACtC,CAAS;QACT,CAAO;AACP;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA,OAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC;QACrB,KAAK,GAAG,SAAS,CAAC;MACxB,CAAK;CACL,KAAI,MAAM,CAAC,SAAS,IAAI,GAAG;CAC3B,YAAW,sCAAsC,GAAG,SAAS,CAAC,CAAC;AAC/D;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA,KAAI,IAAI,gBAAgB,GAAG,CAAC,CAAC;CAC7B,KAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE;QACnC,IAAI,CAAC,aAAa,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE;UACvC,gBAAgB,EAAE,CAAC;QAC3B,CAAO;MACP,CAAK;AACL;CACA;CACA,KAAI,MAAM,aAAa,GAAG,SAAS,CAAC;CACpC,KAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE;CACzC;CACA;QACM,IAAI,CAAC,aAAa,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE;CAC/C,SAAQ,MAAM,CAAC,GAAG,aAAa,GAAG,gBAAgB,CAAC;CACnD,SAAQ,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;UACd,SAAS,IAAI,CAAC,CAAC;QACvB,CAAO;MACP,CAAK;CACL,KAAI,IAAI,WAAW,GAAG,UAAU,GAAG,CAAC,CAAC;CACrC,KAAI,IAAI,WAAW,GAAG,GAAG,CAAC;CAC1B,KAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE;CACzC,OAAM,MAAM,CAAC,GAAG,SAAS,GAAG,WAAW,CAAC;CACxC,OAAM,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QACd,SAAS,IAAI,CAAC,CAAC;CACrB,OAAM,WAAW,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;QACxB,EAAE,WAAW,CAAC;MACpB,CAAK;MACD,MAAM,CAAC,SAAS,IAAI,GAAG,EAAE,iDAAiD,CAAC,CAAC;CAChF,KAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,WAAW,CAAC,GAAG,OAAO,CAAC,CAAC;MAC9C,OAAO,KAAK,CAAC;IACjB,CAAG;AACH;CACA;CACA;CACA;CACA;CACA;CACA;CACA,GAAE,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE;CAChC,KAAI,OAAO,CAAC,GAAG,CAAC,MAAM,GAAG,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC;CAClE,iBAAgB,GAAG,GAAG,IAAI,CAAC,OAAO,GAAG,KAAK,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC;MAC5D,MAAM,IAAI,IAAI,CAAC;CACnB,KAAI,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;CAC5B,KAAI,OAAO,KAAK,IAAI,IAAI,EAAE;QACpB,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;CAC1C,OAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;MAC1B,CAAK;IACL,CAAG;AACH;CACA;CACA;CACA;CACA;CACA,GAAE,cAAc,GAAG;MACf,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IACzC,CAAG;GACF;AACD;CACA;CACA;CACA;CACA,CAAA,kBAAA,CAAA,gBAAwB,GAAG,gBAAgB;;;;;;;;;;;CC1e3C;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;CAEA;CACA;CACA;CACA;CACA;CACA;;CAEA;CACA;CACA;CACA;CACA;CACA;CACA,CAAA,SAAS,mBAAmB,CAAC,IAAI,EAAE,IAAI,EAAE;CACzC,GAAE,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM;CAC1B,GAAE,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM;CAC1B;CACA;CACA,GAAE,MAAM,EAAE,GAAG,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;CAC1E;CACA;CACA,GAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,EAAE;MAC9B,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;CAChB,GAAA;CACA,GAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,EAAE;MAC9B,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;CAChB,GAAA;CACA;CACA;CACA,GAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,EAAE;CAClC,KAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,EAAE;CACpC,OAAM,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;CACvC,SAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;CACnC,OAAA,CAAO,MAAM;UACL,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG;YACjB,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;YAChB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;CAC1B,WAAU,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;WACrB;CACT,OAAA;CACA,KAAA;CACA,GAAA;CACA;CACA,GAAE,OAAO,EAAE,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;CACvB,CAAA;;CAEA;CACA;CACA;CACA;CACA;CACA;CACA,CAAA,SAAS,eAAe,CAAC,IAAI,EAAE,IAAI,EAAE;CACrC,GAAE,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC;CACnD,GAAE,IAAI,MAAM,KAAK,CAAC,EAAE,OAAO,GAAG;CAC9B;IACE,MAAM,QAAQ,GAAG,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC;CAClD,GAAE,OAAO,GAAG,IAAI,QAAQ,GAAG,MAAM,CAAC;CAClC,CAAA;;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;EACA,SAAS,UAAU,CAAC,GAAG,EAAE,MAAM,EAAE,aAAa,GAAG,IAAI,EAAE;IACrD,IAAI,CAAC,aAAa,EAAE;CACtB,KAAI,GAAG,GAAG,GAAG,CAAC,WAAW,EAAE;CAC3B,KAAI,MAAM,GAAG,MAAM,CAAC,WAAW,EAAE;CACjC,GAAA;CACA,GAAE,OAAO,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC;CAC/B,CAAA;;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA,CAAA,SAAS,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,WAAW,GAAG,CAAC,EAAE,aAAa,GAAG,GAAG,EAAE;IAC5E,MAAM,OAAO,GAAG,EAAE;CACpB;CACA,GAAE,KAAK,MAAM,SAAS,IAAI,UAAU,EAAE;MAClC,MAAM,QAAQ,GAAG,mBAAmB,CAAC,MAAM,EAAE,SAAS,CAAC;MACvD,MAAM,UAAU,GAAG,eAAe,CAAC,MAAM,EAAE,SAAS,CAAC;CACzD;MACI,IAAI,QAAQ,IAAI,WAAW,IAAI,UAAU,IAAI,aAAa,EAAE;QAC1D,OAAO,CAAC,IAAI,CAAC;UACX,IAAI,EAAE,SAAS;UACf,QAAQ,EAAE,QAAQ;CAC1B,SAAQ,UAAU,EAAE;CACpB,QAAO,CAAC;CACR,KAAA;CACA,GAAA;CACA;CACA;IACE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK;CACzB,KAAI,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,GAAG,KAAK,EAAE;CACvD,OAAM,OAAO,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,UAAU;CACxC,KAAA;CACA,KAAI,OAAO,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ;CAClC,GAAA,CAAG,CAAC;CACJ;CACA,GAAE,OAAO,OAAO;CAChB,CAAA;;CAEA;CACA;CACA;CACA;CACA;CACA,CAAA,SAAS,kBAAkB,GAAG;CAC9B,GAAE,OAAO;MACL,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CACxB,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;MAC9B,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CAC7B,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;CACnB,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CAClC,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CACjD,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CACjD,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CACjD,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CACjD,KAAI,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;CACjD,KAAI,GAAG,EAAE,CAAC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"}